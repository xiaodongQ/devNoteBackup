# 并发编程

## Linux C/C++

### 程序耗时统计

* 使用`clock()`
    - `#include <time.h>`
    - `clock_t clock(void);`
    - `man 3 clock`
    - 函数的作用是:返回程序所用处理器时间的近似值，获取秒数则除以宏`CLOCKS_PER_SEC`(它用来表示一秒钟会有多少个时钟计时单元)，e.g. `(double)(finish-start)/CLOCKS_PER_SEC`

### fork

* fork
    - fork原型
        + `#include <unistd.h>`
        + `pid_t fork(void);`
            * 成功时：父进程中返回子进程的PID，子进程返回0; 失败时：父进程返回-1，并不创建进程
        + 子进程中进程资源使用率和CPU时间计数都清0了
        + 子进程的挂起信号集初始化为空
        + 子进程`不继承`父进程中：信号量`semaphore`、记录锁`locks`、计时器`timers`、未完成的异步I/O操作和异步I/O上下文
        + 子进程的终止信号总是： `SIGCHLD`； 父进程终止时子进程`不接收`其信号
        + 父进程的整个虚拟地址空间被`复制`到子进程中，包括互斥量`mutexes`、条件变量`condition variables`和其他pthreads对象的状态;
        + 子进程`继承`父进程打开的文件描述符，父子进程的fd指向相同的文件描述符
        + 子进程`继承`父进程打开的消息队列`message queue`
        + 子进程继承父进程打开的目录流`directory streams`
    - man中的NOTES：
        + fork使用`写时复制`实现
        + 子进程复制了父进程的`task_struct`，系统堆栈空间和页面表。子进程未改变变量时，父子进程指向同一块内存，当子进程改变了变量时候（即对变量进行了写操作），会通过`copy_on_write`的手段为所涉及的页面建立一个新的副本。(没有修改资源，就不会有副本被建立)
    - 源码
        + `task_struct结构体`定义在`sched.h`中
        + `fork()`实现在`fork.c`中
        + 关于clone比较可参考：[Linux中fork，vfork和clone详解（区别与联系）](https://blog.csdn.net/gatieme/article/details/51417488)
        + fork创建子进程步骤，可参考：[fork()创建子进程步骤](https://blog.csdn.net/yangcs2009/article/details/39267733)

* getpid原型，获取进程id
    - `#include <sys/types.h>`
    - `#include <unistd.h>`
    - `pid_t getpid(void);`
    - `pid_t getppid(void);`
* `wait()`/`waitpid()` 回收子进程的资源
    - `#include <sys/wait.h>`
    - 流程原理
        + 子进程结束时，系统向其父进程发送SIGCHILD信号；
        + 父进程调用wait函数后`阻塞`；
        + 父进程被SIGCHILD信号唤醒，然后去回收`僵尸子进程`(临时)；
        + 父子进程之间是异步的，SIGCHILD信号机制就是为了解决父子进程之间的异步通信问题，让父进程可以及时的去回收僵尸子进程。
        + 若父进程没有任何子进程则wait返回错误
        + [父进程wait / waitip回收子进程](https://blog.csdn.net/oqqhutu12345678/article/details/75043726)
    - `pid_t wait(int *stat_loc);`
        + `pid_t ret = wait(&status)`
        + status用来返回子进程结束时的状态；
            * 可以用`WIFEXITED`、`WIFSIGNALED`、`WEXITSTATUS`宏判断`status`的状态
        + 返回ret表示本次wait回收的子进程的PID
        + 当前进程可能有多个子进程，wait函数`阻塞`直到`其中一个`子进程结束wait就会`返回`，wait的返回值可以用来判断到底是`哪一个`子进程本次被回收了。(所以若有多个子进程但只回收一次，会有僵尸进程？)
    - `pid_t waitpid(pid_t pid, int *stat_loc, int options);`
        + 和`wait`基本功能一样，都是用来回收子进程；
        + waitpid可以回收指定PID的子进程；
        + waitpid有阻塞式或非阻塞式两种工作模式
        + `pid_t ret = waitpid(-1, &status, 0);`
            * -1表示不等待某个特定PID的子进程而是回收任意一个子进程，0表示用默认的方式（阻塞式）来进行等待，返回值ret是本次回收的子进程的PID。
        + `pid_t ret = waitpid(pid, &status, 0);`
            * 等待回收PID为pid的这个子进程，如果当前进程并没有一个ID号为pid的子进程，则返回值为-1；如果成功回收了pid这个子进程则返回值为回收的进程的PID。
        + `pid_t ret = waitpid(pid, &status, WNOHANG);`
            * 表示父进程要非阻塞式的回收子进程。
            * 此时如果父进程执行waitpid时子进程已经先结束，等待回收，则waitpid直接回收成功，返回值是回收的子进程的PID
            * 如果父进程waitpid时子进程尚未结束则父进程立刻返回（非阻塞），但是返回值为0（表示回收不成功）。

```c
#include <unistd.h>
#include <sys/types.h>

int main(int argc, char const *argv[])
{
    int status = -1;
    if (0 == fork())
    {
        printf("child process, pid:%d, ppid:%d\n", getpid(), getppid());
        sleep(5);
    }
    else
    {
        printf("father process, pid:%d\n", getpid());
        printf("wait...\n");
        // 此处会阻塞，等待子进程直到子进程结束才继续执行
        wait(&status);
        printf("wait end\n");

        // 如果上述不做wait()操作，则子进程结束后父进程还在，就会出现僵尸进程(子进程退出但其结构体并没有被回收)
        // 另一种情况：如果子进程一直存在而父进程退出后(也不做wait()，因为会阻塞等待)，则该子进程变成孤儿进程，父进程变为`1`
        while(1)
        {
            sleep(1);
        }
    }
    return 0;
}
```


## 线程id

* `ps -Tp 进程号`或`top -H`中查看到的线程号，和`gettid()`是一致的，而不是`pthread_self()`，**所以使用`gettid`对应的线程id**
* 在LINUX系统中，POSIX threads库提供了`pthread_t`来标识一个线程，通过`pthread_self()`可以得到
    - `#include <pthread.h>`
    - `pthread_t pthread_self(void);`
    - e.g. 测试获取得到：`thread:[-1917913344]`
    - `typedef unsigned long int pthread_t;`这个数值很大。而且比较两个线程是否相同也需要用`pthread_equal(pthread_t t1, pthread_t t2)`来比较。
    - `pthread_t`是由POSIX pthread库内部提供的，只在进程内部有意义，无法关联操作系统的任务调度之类的信息。比方说在/proc查找不到关于pthread_t得到的task。
* 在LINUX系统中，建议使用`gettid()`系统调用的返回值作为线程id，这么做的原因：
    - 返回值是一个pid_t，其值是一个很小的整数，方便输出。
    - 在linux系统中，它直接标识内核任务调度id，可通过/proc文件系统中找到对应项：/proc/tid 或者 /proc/pid/task/tid，方便定位到具体线程
    - 任何时刻都是唯一的，并且由于linux分配新的pid采用递增轮回办法，短时间内启动多个线程也会具有不同的id
    - 0是非法值，操作系统第一个进程init的pid是1
    - `glibc`没有封装这个`gettid`，需要我们手动封装。
        + 使用比较优雅的方式是定义一个`gettid`的宏：
        + `#define gettid() syscall(__NR_gettid)` 或者 `#define gettid() syscall(SYS_gettid)`
        + 需要包含头文件：`#include <sys/syscall.h>`

## 时间片和进程优先级

* 背景
    - 实际开发场景中，持续循环处理中若不加任何的sleep/usleep，如果条件都不满足则会迅速地进行轮询(busy loop)，此时线程占用着CPU时间片，很容易导致CPU使用率100%(top查看或upload查看平均负载)。
        + 一般加一些睡眠时间出让时间片并在睡眠期间不参与CPU抢占，自己长用1ms、10ms。部分相关原理参考下面文章
- [linux内核调度算法（2）–CPU时间片如何分配](https://cloud.tencent.com/developer/article/1449443)
    + 内核分配时间片时，相较于CPU密集型进程，会多分配时间片给IO密集型进程？
        * 内核分配时间片是有策略和倾向性的，通过动态调整进程的优先级，以及分配不同长短的CPU时间处来实现
    + 内核如何决定时间片的长度
        * 对每一个进程，有一个整型`static_prio`表示用户设置的静态优先级，内核里它与`nice`值是对应的。
        * `nice`的取值范围是`-20到+19`，-20优先级最高，+19最低。
            - top可查看到`NICE`值，可通过`nice`和`renice`命令手动调整。
            - top中输入`r`后，按照提示输入进程号回车，再输入新NICE值即可
            - 输入后进程优先级会随之更改(如提升优先级将NICE设置为-1，则普通用户进程原来默认的优先级20，会变为19)
        * `DEF_TIMESLICE`默认的时间片是100ms。假设nice值是-20，那么`static_prio`就是100，那么`SCALE_PRIO(100*4, 100)`(该宏传入优先级和优先级相关时间，返回时间片ms，可参考链接)就等于800，意味着
            - 最高优先级-20情形下，可以分到时间片是`800ms`；
            - 如果nice值是+19，则只能分到最小时间片`5ms`；
            - nice值是默认的0则能分到`100ms`。
    + 另外该系列的另两篇文章也值得一读
        * [linux内核调度算法（1）–快速找到最高优先级进程](https://cloud.tencent.com/developer/article/1449444)
            - 没个CPU包含一个`runqueue`，其中包含一个自旋锁`spinlock_t lock`，nginx里解决`惊群现象`时也是使用这个
            - [自旋锁和互斥锁区别](https://blog.csdn.net/sunmenggmail/article/details/8105279)
                + 相较与互斥锁(mutex)将等待锁的线程置于等待队列中，自旋锁会忙等待并不停的进行锁请求(busy-waiting类型)，直到得到这个锁为止。所以，自旋锁一般用于多核的服务器。
                + 慎重使用自旋锁，自旋锁只有在内核可抢占式或SMP的情况下才真正需要，在单CPU且不可抢占式的内核下，自旋锁的操作为空操作。自旋锁适用于锁使用者保持锁时间比较短的情况下。
        * [linux内核调度算法（3）–多核系统的负载均衡](https://cloud.tencent.com/developer/article/1449436)
    + 有时间可动手进行相关模拟：[时间片轮转算法和优先级调度算法模拟实现](https://www.cnblogs.com/zhying99/articles/9870615.html)
