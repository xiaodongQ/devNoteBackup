# 分布式和微服务

## Consul

* Consul
    - 分布式服务发现和配置
    - 协议：Mozilla Public License 2.0，只要该许可证的代码在单独的文件中，新增的其他文件可以不用开源
    - [用 Consul 来做服务注册与服务发现](https://segmentfault.com/a/1190000018731395)
        + 为什么需要有服务注册与服务发现？
            * 环境背景：分布式系统中有服务Service-A(S-A)和Service-B(S-B)，S-A调用S-B
            * 演进过程：服务规模小只有一个S-B (演进)-> 每个服务不止部署一个实例(此时多个S-B如何调用?) -> 引入Nginx -> 某服务实例挂掉后需要Nginx不向其分配请求 -> 引入"`服务注册和服务发现工具`" (架构图参考链接) -> 引入Consul(或其他工具)
        + 业界常用的服务注册与服务发现工具有 `ZooKeeper`、`etcd`、`Consul` 和 `Eureka`，Consul和其区别参考链接中的链接
        + Consul 作为一种分布式服务工具，为了避免单点故障常常以集群的方式进行部署，在 Consul 集群的节点中分为 `Server` 和 `Client` 两种节点（所有的节点也被称为`Agent`）
            * Server 节点保存数据，Client 节点负责健康检查及转发数据请求到 Server；
            * Server 节点有一个 `Leader` 节点和多个 `Follower` 节点，Leader 节点会将数据同步到 Follower 节点，在 Leader 节点挂掉的时候会启动选举机制产生一个新的 Leader。
            * Client 节点很轻量且无状态，它以 RPC 的方式向 Server 节点做读写请求的转发，此外也可以直接向 Server 节点发送读写请求。 Consul 的架构图参考链接。
    - [Consul 使用手册](http://www.liangxiansen.cn/2017/04/06/consul/)

* 官网文档：[HashiCorp Consul Documentation](https://www.consul.io/docs/index.html)
* 入门使用文档，[GETTING STARTED](https://learn.hashicorp.com/consul?track=getting-started#getting-started)
    - 安装
        + Download Consul：[官网下载地址](https://www.consul.io/downloads.html)
        + zip包中只有一个`consul`二进制文件(104M, `consul_1.6.2_linux_amd64`)，执行路径添加到PATH环境变量即可
    - 启动`Consul agent`
        + 每个`Consul agent`都运行在`server`或者`client`模式。
        + 每个Consul数据中心都至少有一个`server`，负责维护Consul的状态
            * 包括其他Consul server和client、什么服务可被发现、哪些服务可以和其他服务交互
            * 注意：强烈反对单服务器产品部署Consul

## hystrix

* hystrix
    - 服务熔断和降级

## 缓存

* [淘宝开源 Key/Value 结构数据存储系统 Tair 技术剖析](https://www.infoq.cn/article/taobao-tair/)
    - Tair 是由淘宝网自主开发的 Key/Value 结构数据存储系统，在淘宝网有着大规模的应用
    - 默认支持基于内存和文件的两种存储方式，分别和我们通常所说的缓存和持久化存储对应
- [技术选型系列 - Tair&Redis对比](https://cloud.tencent.com/developer/article/1371099)

## 一致性哈希

* 进一步学习可参考：[24 | 一致性哈希：如何高效地均衡负载？](https://time.geekbang.org/column/article/256780)
    - 以及自己对该文章的学习笔记(搜索`24 | 一致性哈希：如何高效地均衡负载？`)：[devNoteBackup/各语言记录/Linux性能优化实践.md](https://github.com/xiaodongQ/devNoteBackup/blob/master/%E5%90%84%E8%AF%AD%E8%A8%80%E8%AE%B0%E5%BD%95/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5.md)
* 一个Go实现版本：[naza/pkg/consistenthash/](https://github.com/q191201771/naza/tree/master/pkg/consistenthash)
    - 哈希函数默认(可更改)用的是：`crc32.ChecksumIEEE` (hash/crc32包)
        + 循环冗余校验（`Cyclic Redundancy Check`， `CRC`）是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种信道编码技术，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的
            * [CRC （循环冗余校验）](https://baike.baidu.com/item/CRC/1453359)
* 循环冗余校验（CRC）算法
    - [循环冗余校验（CRC）算法入门引导](https://blog.csdn.net/liyuanbhu/article/details/7882789)
    - 从`奇偶校验`说起
        + 所谓奇偶校验就是在发送的每一个字节后都加上一位，使得每个字节中1的个数为奇数个或偶数个
            * 比如我们要发送的字节是`0x1a`，二进制表示为`0001 1010`
            * 采用奇校验(让该字节二进制中1的个数凑成奇数个)，则在数据后补上个0(因为原来已经为3个1)，数据变为`0001 1010 0`，数据中1的个数为奇数个（3个）
            * 采用偶校验，则在数据后补上个1(为了凑成偶数个1，3+1)，数据变为`0001 1010 1`，数据中1的个数为偶数个（4个）
        + 接收方通过计算数据中1个数是否满足奇偶性来确定数据是否有错
        + 奇偶校验的缺点很明显
            * 首先，它对错误的检测概率大约只有50%。也就是只有一半的错误它能够检测出来。
            * 另外，每传输一个字节都要附加一位校验位，对传输效率的影响很大
            * 因此，在高速数据通讯中很少采用奇偶校验
        + 奇偶校验优点也很明显
            * 它很简单，因此可以用硬件来实现，这样可以减少软件的负担。
            * 因此，奇偶校验也被广泛的应用着
        + 之所以从奇偶校验说起，是因为这种校验方式最简单，而且后面将会知道奇偶校验其实就是CRC 校验的一种(`CRC-1`)
    - `累加和校验`
        + 另一种常见的校验方式是累加和校验
        + 所谓累加和校验实现方式有很多种，最常用的一种是在一次通讯数据包的最后*加入一个字节的校验数据*。这个字节内容为前面数据包中全部数据的*忽略进位的按字节累加和*
            * e.g. 要传输的信息为： `6、23、4`，加上校验和后的数据包：`6、23、4、33`
        + 累加和校验由于实现起来非常简单，也被广泛的采用。
            * 但是这种校验方式的检错能力也比较一般，对于单字节的校验和大概有`1/256`的概率将原本是错误的通讯数据误判为正确数据
        + 之所以这里介绍这种校验，是因为CRC校验在传输数据的形式上与累加和校验是相同的，都可以表示为：通讯数据 校验字节（也可能是多个字节）
    - 初识 `CRC 算法`
        + CRC算法的基本思想是将传输的数据当做一个位数很长的数。
            * 将这个数除以另一个数。得到的`余数`作为校验数据附加到原数据后面
        + 还是上面的例子数据
            * `6、23、4` 可以看做一个2进制数： 00000110 00010111 00000100
            * 假如被除数选9，二进制表示为：1001
            * 除法过程参考链接，可看到最后的余数为1。如果我们将这个余数作为校验和的话，传输的数据则是：`6、23、4、1`
            * CRC 算法和这个过程有点类似，不过采用的不是上面例子中的通常的这种除法
        + 在CRC算法中，将二进制数据流作为多项式的系数，然后进行的是`多项式的乘除法`
            * 乘法：
                - 比如有两个二进制数，分别为：1101 和1011
                - 1101 与如下的多项式相联系：`1x^3+1x^2+0x^1+1x^0=x^3+x^2+x^0`
                - 1011与如下的多项式相联系：`1x^3+0x^2+1x^1+1x^0=x^3+x^1+x^0`
                - 两个多项式的乘法：`(x^3+x^2+x^0)(x^3+x^1+x^0)=x^6+x^5+x^4+x^3+x^3+x^3+x^2+x^1+x^0`
                - 得到结果后，合并同类项时采用模2运算，所谓模2运算就是结果除以2后取余数，即`x^3+x^3+x^3`变为`x^3`(即异或)
                - 上面最终得到的多项式为：`x^6+x^5+x^4+x^3+x^2+x^1+x^0`，对应的二进制数:`111111`
            * 除法
                - 除法运算与上面给出的乘法概念类似，还是遇到加减的地方都用`异或`运算来代替
                - 例如要传输的数据为：1101011011，除数为：10011
                    + 在计算前先将原始数据后面填上4个0：11010110110000
                    + 位宽为4（W=4），按照CRC算法的要求，计算前要在原始数据后填上W个0，也就是4个0
                - 参考链接图示，每次相除时不需要考虑借位的问题(异或得到本次结果)，所以除法变简单了
                - 最后得到的余数就是`CRC 校验字`
            * 为了进行CRC运算，也就是这种特殊的除法运算，必须要指定个被除数，在CRC算法中，这个被除数有一个专有名称叫做“`生成多项式`”
                - 生成多项式的选取是个很有难度的问题，如果选的不好，那么检出错误的概率就会低很多
                - 这个问题已经被专家们研究了很长一段时间了，对于我们这些使用者来说，只要把现成的成果拿来用就行了
                - 最常用的几种生成多项式如下：
                    + `CRC8=X^8+X^5+X^4+X^0`，还有CRC16、CRC12等
                    + `CRC32=X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0`
                - 文献中提到的生成多项式经常会说到多项式的`位宽`（Width，简记为W），这个位宽不是多项式对应的二进制数的位数，而是位数减1
                    + 比如CRC8中用到的位宽为8的生成多项式，其实对应的二进制数有九位 100110001
