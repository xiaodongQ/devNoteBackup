# 设计模式

## 设计原则与思想：面向对象

* 封装、抽象、继承、多态
* 抽象类 和 接口，以及各自应用场景
	- 抽象类是`is-a`关系，是对成员变量和方法的抽象，是为了解决代码复用问题；
	- 接口是`has-a`关系，仅仅是对方法的抽象。是为了解决耦合问题，隔离接口和具体的实现，提高代码的扩展性
	- [08 | 理论五：接口vs抽象类的区别？如何用普通的类模拟抽象类和接口？](https://time.geekbang.org/column/article/165103)
* 基于接口编程而非实现编程
* 多用组合，少用继承
	- [10 | 理论七：为何说要多用组合少用继承？如何决定该用组合还是继承？](https://time.geekbang.org/column/article/169593)
* 贫血模型 和 充血模型
	- 基于贫血模型的MVC架构
		+ [11 | 实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？](https://time.geekbang.org/column/article/169600)
	- 基于充血模型的DDD开发

## 设计原则与思想：设计原则

一些经典的设计原则，其中包括，`SOLID`、`KISS`、`YAGNI`、`DRY`、`LOD` 等。

* SOLID
	- SOLID 原则并非单纯的 1 个原则，而是由5个设计原则组成的(SOLID 中的 S、O、L、I、D 这 5 个英文字母)，它们分别是：
		+ `单一职责原则` (Single Responsibility Principle, SRP)
			* 单一职责原则的英文是 `Single Responsibility Principle`，缩写为 `SRP`。
			* 描述：*一个类或者模块只负责完成一个职责（或者功能）(A class or module should have a single reponsibility)*
			* 不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定，可能都是不一样的
			* 不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。
			* [15 | 理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？](https://time.geekbang.org/column/article/171771)
		+ `开闭原则` (Open Closed Principle, OCP)
			* 开闭原则的英文全称是 `Open Closed Principle`，简写为 `OCP`
			* 描述：*软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。(software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification)*
			* 添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。
			* [16 | 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？](https://time.geekbang.org/column/article/176075)
		+ `里式替换原则` (Liskov Substitution Principle, LSP)
			* 里式替换原则的英文翻译是：`Liskov Substitution Principle`，缩写为 `LSP`
				- 这个原则最早是在 1986 年由 Barbara Liskov 提出
			* 描述：*子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏*
			* 多态和里式替换原则说的是不是一回事呢？从链接中的例子和定义描述来看，里式替换原则跟多态看起来确实有点类似，但实际上它们完全是两回事
				- 多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性
			* 理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。
				- 父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。
				- 这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明
			* [17 | 理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？](https://time.geekbang.org/column/article/177110)
		+ `接口隔离原则` (Interface Segregation Principle, ISP)
			* 描述：*客户端不应该强迫依赖它不需要的接口。(Clients should not be forced to depend upon interfaces that they do not use)*
				- 其中的“客户端”，可以理解为接口的调用者或者使用者
				- 链接中的示例，用户相关的一套接口方法中，包含删除用户的操作，对其改进为将特权操作单独定义一个接口，而实现类可以选择实现两个interface
			* 在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口
			* 参考链接中的示例：
				- 支持Redis和Kafka配置信息的热更新，但因为某些原因，我们并不希望对 MySQL 的配置信息进行热更新
				- `interface Updater{void update();}`，`RedisConfig`和`KafkaConfig`都实现了Updater接口，用于进行热更新，`MysqlConfig`则不实现Updater接口
				- 再在一个`ScheduledUpdater`类中进行操作，类中定义了一个Updater成员(这样就可以用多态的方式调用方法了)，并且该成员由构造函数来通过外部定义时进行赋值，实现热更新则`Updater.update()`即可(调用写在`run()`方法中)
				- 使用：定义两个`ScheduledUpdater`变量，并分别送需要支持热更新的`RedisConfig`，`KafkaConfig`类给构造函数，于是就可以各自调用两个变量中的`run()`更新逻辑了
			* 作为对比：如果我们不遵守接口隔离原则，不设计 Updater 和 Viewer 两个小接口，而是设计一个大而全的 Config 接口，让 RedisConfig、KafkaConfig、MysqlConfig 都实现这个 Config 接口，并且将原来传递给 ScheduledUpdater 的 Updater 和传递给 SimpleHttpServer 的 Viewer，都替换为 Config，那会有什么问题呢？
				- 首先，第一种设计思路更加灵活、易扩展、易复用：职责更加单一，单一就意味了通用、复用性好
				- 其次，第二种设计思路在代码实现上做了一些无用功。因为 Config 接口中包含两类不相关的接口。
					+  除此之外，如果我们要往Config中继续添加一个新的接口，那所有的实现类都要改动。相反，如果我们的接口粒度比较小，那涉及改动的类就比较少
			* [18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？](https://time.geekbang.org/column/article/177442)
		+ `依赖反转原则` (Dependency Inversion Principle, DIP)，有时也翻译为`依赖倒置原则`
			* 在讲“依赖反转原则”之前，我们先讲一讲`“控制反转”` (Inversion Of Control，IOC)
				- 示例中的框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。
				- 这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行；在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架
				- 控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计
			* 接下来，我们再来看`依赖注入` (Dependency Injection，DI)
				- 依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧
				- 用一句话来概括就是：不通过new()的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用
			* 依赖反转原则：*高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）*
				- 所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层
			* [19 | 理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？](https://time.geekbang.org/column/article/177444)
* `KISS` (Keep It Simple and Stupid)
	- KISS 原则的英文描述有好几个版本：
		+ Keep It Simple and Stupid
		+ Keep It Short and Simple
		+ Keep It Simple and Straightforward
	- 它们表达的意思其实差不多，翻译成中文就是：*尽量保持简单*
		+ 不过，并不是代码行数越少就越“简单”(Simple)，参考链接中验证IP是否合法的示例，使用正则表达式代码最少，但是正则表达式本身就比较复杂，所以并不满足KISS原则
		+ 如果一段代码的逻辑复杂、实现难度大、可读性也不太好，也不一定违背KISS原则，如示例中KMP算法本身就具有`逻辑`复杂、`实现难度`大、`可读性`差的特点。同样的代码，在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了
	- 如何写出满足 KISS 原则的代码
		+ 不要使用同事可能不懂的技术来实现代码
			* 比如示例中的正则表达式，还有一些编程语言中过于高级的语法等
		+ 不要重复造轮子，要善于使用已经有的工具类库
			* 经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高
		+ 不要过度优化
			* 不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性
	- 实际上代码是否足够简单是一个挺主观的评判，评判代码是否简单，还有一个很有效的间接方法，那就是 code review。如果在 code review 的时候，同事对你的代码有很多疑问，那就说明你的代码有可能不够“简单”，需要优化啦
	- [20 | 理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？](https://time.geekbang.org/column/article/177448)
* `YAGNI` (You Ain’t Gonna Need It)
	- YAGNI 原则的英文全称是：You Ain’t Gonna Need It。直译就是：*你不会需要它*
	- 当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：*不要做过度设计*。
		+ 当然，这并不是说我们就不需要考虑代码的扩展性，预留好扩展点
		+ 比如不要在项目中提前引入不需要依赖的开发包
	- YAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。
* `DRY` (Don’t Repeat Yourself)
	- 中文直译为：不要重复自己。将它应用在编程中，可以理解为：*不要写重复的代码*
	- 实际上，重复的代码不一定违反 DRY 原则，而且有些看似不重复的代码也有可能违反 DRY 原则
	- 三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复
		+ 实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则。
		+ 实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则。
		+ 除此之外，代码执行重复也算是违反 DRY 原则。
	- 提高代码可复用性的一些方法，有以下 7 点。
		+ 减少代码耦合
		+ 满足单一职责原则
		+ 模块化业务与非业务逻辑分离
		+ 通用代码下沉
		+ 继承、多态、抽象、封装
		+ 应用模板等设计模式
	- 此外，复用意识也非常重要。在设计每个模块、类、函数的时候，要像设计一个外部 API 一样去思考它的复用性。
		+ 我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。
	- 我们可以不写可复用的代码，但一定不能写重复的代码。
	- [21 | 理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？](https://time.geekbang.org/column/article/179607)
* `LOD`(Law of Demeter)
	- 高内聚、松耦合
		+ 所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护
			* 单一职责原则是实现代码高内聚非常有效的设计原则
		+ 所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。 即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。
			* 前面讲的依赖注入、接口隔离、基于接口而非实现编程，以及今天讲的迪米特法则，都是为了实现代码的松耦合。
	- 迪米特法则的英文翻译是：Law of Demeter，缩写是LOD。单从这个名字上来看，我们完全猜不出这个原则讲的是什么。不过，它还有另外一个更加达意的名字，叫作*最小知识原则*，英文翻译为：The Least Knowledge Principle
		+ 每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。
		+ *不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）*
	- [22 | 理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？](https://time.geekbang.org/column/article/179615)