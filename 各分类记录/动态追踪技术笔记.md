# 动态追踪技术笔记

性能优化和问题定位中，动态追踪技术都有很大的施展空间，此处做为学习和实践记录

## SystemTap

官网手册：https://sourceware.org/systemtap/tutorial/

### 基本介绍

基本中文介绍，参考：https://zhuanlan.zhihu.com/p/347313289  
(*具体用法和一手内容还是建议到上述官网去消化，下述`官网文档笔记记录`小节*)

systemtap是一个用于简化linux系统运行形态信息收集的开源工具。它立足于性能诊断和bug调试，消除了开发人员在收集数据时需要经历的繁琐和破坏性的工具、重新编译、安装和重新引导的过程。使开发人员在应用层即可实现hook内核

工作原理是通过**将脚本语句翻译成C语句，编译成内核模块**。模块加载之后，将所有探测的事件以钩子的方式挂到内核上，当任何处理器上的某个事件发生时，相应钩子上句柄就会被执行。最后，当systemtap会话结束之后，钩子从内核上取下，移除模块。整个过程用一个命令 stap 就可以完成。

基本用法：

1. `stap 脚本`，可以传参，并用 $N(表示整数) 或 @N(表示字符串) 引用
2. `stap -e '实现'` 通过命令行指定脚本内容(单引号和双引号均可)
    - 如：`stap -e 'probe syscall.* { }'`
3. `stap -l '单个探测点'`，相对脚本，该方式只有一个探测点
    - 如：`stap -l 'syscall.*'`，部分结果：syscall.wait4
4. `stap -L '单个探测点'`
    - 和-l类似，不过匹配的探测点会加上参数说明
    - 如：`stap -L 'syscall.*'`，部分结果：syscall.wait4 name:string pid:long status_uaddr:long options:long options_str:string rusage_uaddr:long argstr:string

语法简介：

* 脚本命名
    - 脚本名字符合linux文件命名即可。一般名字后辍使用".stp"
* 注释
    - 脚本支持多种注释方式，# 、//、/**/ 均可
    - 类似其他脚本，systemtap脚本在开头也需要标明脚本解析器的路径，一般是"#!/usr/bin/stap"，不确定可用which查询
* 变量
    定义全局变量需要加"global"
    数组必须被定义成"global"变量，默认大小不超过2048(MAXMAPENTRIES)，定义时可以省略大小
    支持关联数组(哈希数组)，关联数组中的索引或键由一个或多个字符串或整数值(逗号隔开)组成：
        arr1[“foo”] = 14
        arr2[“coords”,3,42,7] = “test”
* 控制
    - 和C一样
    - 支持foreach语法
* 函数
    - function testfunc:int (i:int){}，类型在后面
    - probe函数
        + 探测内核函数
            * probe kernel.function("kernel_function_name"){ ... }
        + 模块函数
            * probe module("module_name").function("module_function_name") { ... }
    - 函数名支持通配符
    - 在函数末尾加上“.call”或“.return”，分别表示函数被调用和返回时probe
* 可通过命令行传参给脚本
    - "$N" 引用整数类型
    - "@N" 引用字符串类型。如果字符串中间有空格，需要在字符串两边加上双引号
    - 示例
        + stap script.stp sometext 42，脚本中引用时：printf(“arg1: %s, arg2: %d\n”, "@1", $2)

安装：  
yum install systemtap

另需：  
yum install kernel-devel

另外需要 kernel-debuginfo和kernel-debuginfo-common包，需要下载rpm包 (调试内核必然需要安装内核debuginfo包)  
    注意kernel-debug是另外的包，和上面debuginfo不同  
    根据后续的实验结果，stap翻译脚本文件时需要debuginfo包，注意是kernel-debuginfo，而不是kernel-debug-debuginfo包

### 安装和简单示例操作

先 `yum install systemtap` 安装systemtap，网上文章说要另外安装kernel-devel、kernel-debuginfo和kernel-debuginfo-common。

先不装其他包，看执行会缺少什么东西，开始踩坑之旅。

实例(stap -L)：(https://zhuanlan.zhihu.com/p/347345502)

1) 新增test.c写简单逻辑，-g编译成可执行文件
2) stap查看该程序探测点

    stap -L 'process("a.out").function("*")'

    报错：Checking "/lib/modules/4.4.77/build/.config" failed with error: No such file or directory

```
    原因(网上找的，下面实验确认)：最开始只安装了systemtap，需要内核开发包kernel-devel
        安装时提示3.10.0-1160内核(小版本也要特别注意)，还是报错。填的http的yum源是3.10内核的，卸载刚安装的kernel-devel
        制作本地yum源，7.7 everything，默认就是3.10，还是先维持3.10内核
    调整grub加载顺序，让加载的内核为3.10
        /boot/grub2/grub.cfg中， set default="1"(看环境第1个是4.4.77，第2个是3.10)
    安装了还是一样，暂卸载kernel-devel
    /lib/modules/3.10.0-1062.el7.x86_64/build是软连接，指向不存在
        Incorrect version or missing kernel-devel package, use: yum install kernel-devel-3.10.0-1062.el7.x86_64 
        [root@localhost xd]# ll /lib/modules/3.10.0-1062.el7.x86_64/build
        lrwxrwxrwx. 1 root root 39 Dec  1  2020 /lib/modules/3.10.0-1062.el7.x86_64/build -> /usr/src/kernels/3.10.0-1062.el7.x86_64
    /usr/src/kernels/3.10.0-1160.el7.x86_64.debug存在，手动调整软连接指向该目录，在该`-L`示例里可以了。
    ( **但其他功能还是受影响，在下例中需要编译ko的场景下，小版本也必须一致！具体见下面示例**)
        ln -sf /usr/src/kernels/3.10.0-1160.el7.x86_64.debug /lib/modules/3.10.0-1062.el7.x86_64/build
```

基本功能操作: stap -e

```
[root@localhost xd]# stap -ve 'probe begin{printf("Hello, World\n"); exit();}'
Pass 1: parsed user script and 481 library scripts using 275188virt/72448res/3484shr/69212data kb, in 760usr/40sys/803real ms.
Pass 2: analyzed script: 1 probe, 1 function, 0 embeds, 0 globals using 276904virt/74292res/3704shr/70928data kb, in 10usr/0sys/9real ms.
Pass 3: translated to C into "/tmp/stap4Y7BwP/stap_746b6d746dec95b9c5547db709e646df_985_src.c" using 276904virt/74816res/4208shr/70928data kb, in 0usr/0sys/0real ms.
Pass 4: compiled C into "stap_746b6d746dec95b9c5547db709e646df_985.ko" in 9580usr/2120sys/12312real ms.
Pass 5: starting run.
ERROR: Couldn't insert module '/tmp/stap4Y7BwP/stap_746b6d746dec95b9c5547db709e646df_985.ko': Invalid module format
WARNING: /usr/bin/staprun exited with status: 1
Pass 5: run completed in 10usr/0sys/15real ms.
Pass 5: run failed.  [man error::pass5]
```

排查尝试：

```
    安装kernel-devel，报错一样
    安装kernel-debuginfo、kernel-debuginfo-common，还是一样的报错
        搜索centos-debuginfo，此处选一个阿里云的：https://developer.aliyun.com/mirror/centos-debuginfo/
        uname查看内核版本为3.10.0-1062.el7.x86_64，下载对应版本
            kernel-debuginfo-common-x86_64-3.10.0-1062.el7.x86_64.rpm (61.4MB)
            kernel-debuginfo-3.10.0-1062.el7.x86_64.rpm (437MB，rpm -iv安装时依赖上述的common)
    三个包的内核版本需要一致？上述修改的软连接指定的内核小版本不同，只是强行手动改了软连接
        查看编出来缓存的ko info信息，小版本果然是不同的，上面改的指向不行(系统是3.10.0-1062，但是目录下是1160，这就比较坑了)
        [root@localhost ~]# modinfo /root/.systemtap/cache/7b/stap_7b73a7adf44ee5b3a46d011f337cee93_985.ko
        filename:       /root/.systemtap/cache/7b/stap_7b73a7adf44ee5b3a46d011f337cee93_985.ko
        license:        GPL
        description:    systemtap-generated probe
        license:        GPL
        retpoline:      Y
        rhelversion:    7.9
        srcversion:     623FDCE05AF4D4BCFA508BB
        depends:        
        vermagic:       3.10.0-1160.el7.x86_64.debug SMP mod_unload modversions 
        parm:           _stp_bufsize:buffer size (int)
    安装debuginfo包后，存在1062版本的debug目录，是否可以修改上述的build指向？：
        [root@localhost systemtap_dep]# find / -name "*3.10.0-1062*"
        /usr/src/debug/kernel-3.10.0-1062.el7
        /usr/src/debug/kernel-3.10.0-1062.el7/linux-3.10.0-1062.el7.x86_64
        /usr/src/kernels/3.10.0-1160.el7.x86_64.debug/3.10.0-1062.el7.x86_6
        结果：不行，依赖里面的.config
    find找到一个3.10.0-1062版本(容器镜像)，要不先链接试下
        /data/docker/volumes/7f9b50d518aa1fc84082a5037298fce36e07767120bb92b4d256e4778c879d10/_data/3.10/linux-3.10.0-1062.el7/.config
        ln -sf xxx /lib/modules/3.10.0-1062.el7.x86_64/build
        不报上面的错误了，报错，容器镜像里没带小版本：
            Pass 5: starting run.
            ERROR: module release mismatch (3.10.0 vs 3.10.0-1062.el7.x86_64)
            ERROR: module version mismatch (#1 SMP Tue Jun 14 16:01:32 CST 2022 vs #1 SMP Wed Aug 7 18:08:02 UTC 2019), release 3.10.0
        结果：不行
    装devel后(从挂载的系统镜像里取的该版本rpm)，存在/usr/src/kernels/3.10.0-1062.el7.x86_64/了，还原之前的链接
        可以了。。
```

* 所以正确的顺序是：

    1. yum install systemtap

    2. 安装 yum install kernel-devel，特别注意内核版本

        rpm -qa|grep kernel-devel检查系统内核和该包内核，小版本也必须一致(踩的坑：配置的yum源里的小版本为3.0.10-1160，比1062高一些)

        如果yum源里的内核版本不一样，从镜像mount之后取rpm包进行安装(kernel-devel-3.10.0-1062.el7.x86_64.rpm)

        会安装在/usr/src/kernels

    3. 安装debuginfo包，否则stap 指定脚本时会编译失败  
        WARNING: cannot find module kernel debuginfo: No DWARF information found [man warning::debuginfo]

回顾小结：  
    有主动也有被动给自己设了点坑：  
    1、不安装推荐的包，在出错的边缘试探  
    2、主要依赖的kernel-devel包，安装的版本和内核版本不完全一致，都是3.10.0，但后面的小版本不同  
    3、实验的环境不标准(安装了两个内核，grub启动项不同)，忽略了yum源的内核版本问题  

### 官网文档笔记记录

#### 追踪

几种用法和内建tapset库，具体见：[Tracing](https://sourceware.org/systemtap/tutorial/tutorialse2.html#x4-30002)

(可以find / -name tapset，而后grep去查看具体内建函数的实现)

* 常见用法
    - `begin`、`end`，systemtap会话开始和结束，比如`probe begin{}`里面指定一些标题列打印
    - `kernel.function("sys_open")`，探测进入到指定内核函数(可查看内核源码后指定函数进行探测)
        + `kernel.function("*@net/socket.c").call`，可进一步指定某源码文件及探测时机
    - `syscall.close.return`，探测系统调用，可进一步指定是调用时(.call)还是返回时(.return)
    - `module("ext3").statement(0xdeadbeef)`
    - `timer.ms(200)`，每200ms执行一次，指定exit()则可单次使用
    - `timer.profile`、`perf.hw.cache_misses`、`procfs("status").read`
    - `process("a.out").statement("*@main.c:200")` 可指定用户进程
    - 还有：
        + `probe signal.send` 监测信号发送

* systemtap支持很多内建事件(tapset)，常见内建函数和变量：
    - execname() 当前进程名
        + 如：pmdalinux
    - pid() 当前进程号、tid()当前线程号
    - uid() 当前用户id
    - cpu() 当前cpu号
    - pp() 当前处理探测点的字符串描述
        + 如：kprobe.function("__x64_sys_openat")
    - ppfunc() 探测点函数名
        + __x64_sys_openat
    - print_backtrace() 打印调用栈(如果可能的话，If possible)
        + 试了下打印出来没对应到%s位置，缓冲区或者格式化可能没设置好
    - print_ubacktrace() 打印用户态调用栈(如果可能的话)
    - thread_indent() 是很有用的一个函数
        + 可以输出当前probe所处的可执行程序名称、线程id、函数执行的相对时间和执行的次数（通过空格的数量）信息，它的返回值就是一个字符串。参数delta是在每次调用时增加或移除的空白数量 (未梳理如何得到相对时间的，参考：https://www.cnblogs.com/10087622blog/articles/9592036.html)
        + 查看其实现为：`return _generic_indent (tid(), sprintf("%s(%d)", execname(), tid()), delta)`
        + 如下例所示，这样可以打印函数入口到出口之间，函数执行的时间(us)

```sh
probe kernel.function("*@net/socket.c").call {
  printf ("%s -> %s\n", thread_indent(1), ppfunc())
}
probe kernel.function("*@net/socket.c").return {
  printf ("%s <- %s\n", thread_indent(-1), ppfunc())
}

# 部分结果示例：
# 0 sshd(20817): -> sock_write_iter
# 2 sshd(20817):  -> sock_sendmsg    # 说明执行花了2us
# 53 sshd(20817):  <- sock_sendmsg   # 说明执行花了53us
# 54 sshd(20817): <- sock_write_iter
# 0 sshd(20817): -> sock_poll
```

* 其他
    - argstr 执行时送的参数列表 ?

```sh
# cat strace-open.stp
probe syscall.open
{
  printf ("%s(%d) open (%s)\n", execname(), pid(), argstr)
}
probe timer.ms(4000) # after 4 seconds
{
  exit ()
}
# 说明：可以安装两个探测点，exit则退出整体追踪，此处效果即探测open系统调用，4s后结束(shell命令多为直接调用opencat())
# 执行效果如下：
# irqbalance(1126) open (AT_FDCWD, "/proc/irq/9/smp_affinity", O_RDONLY)
# pmdalinux(1775) open (AT_FDCWD, "/proc/vmstat", O_RDONLY)
```

#### 分析

https://sourceware.org/systemtap/tutorial/tutorialse3.html#x6-70003

systemtap语句和C类似

* 几个实用示例
    - (cpu() == 0 && gettimeofday_s() > 1140498000)	after Feb. 21, 2006, on CPU 0
        + 以后可利用gettimeofday_s()来指定时间点(date -d @xxx可解析查看)

* 几个操作符说明
    - & 取地址
    - $$ pretty打印结构体
    - $$vars pretty打印多个变量
    - @defined 检查是否有效

```sh
# cat inode-watch.stp (功能是监控指定设备上inode号表示的文件读写)
probe kernel.function ("vfs_write"),
      kernel.function ("vfs_read")
{
  if (@defined($file->f_path->dentry)) {
    dev_nr = $file->f_path->dentry->d_inode->i_sb->s_dev
    inode_nr = $file->f_path->dentry->d_inode->i_ino
  } else {
    dev_nr = $file->f_dentry->d_inode->i_sb->s_dev
    inode_nr = $file->f_dentry->d_inode->i_ino
  }

  if (dev_nr == ($1 << 20 | $2) # major/minor device
      && inode_nr == $3)
    printf ("%s(%d) %s 0x%x/%u\n",
      execname(), pid(), ppfunc(), dev_nr, inode_nr)
}
```

执行：

```
# touch /tmp/xd123
# stat -c "%D %i" /tmp/xd123 (-c指定format，%D为16进制的设备号，%i为inode号)
fd00 69921712

# stap inode-watch.stp 0xfd 0 69921712  (而后echo 123 > /tmp/xd12，cat、more等操作均会监控)
zsh(74006) vfs_write 0xfd00000/69921712
zsh(74006) vfs_write 0xfd00000/69921712

cat(74819) vfs_read 0xfd00000/69921712
cat(74819) vfs_read 0xfd00000/69921712
cat(74819) vfs_read 0xfd00000/69921712
cat(74819) vfs_read 0xfd00000/69921712
```

#### tapsets 脚本复用

https://sourceware.org/systemtap/tutorial/tutorialse4.html#x10-150004

* man手册里面有各类tapset说明：
    - `man tapset::` (不回车)然后tab提示
    - 如 man tapset::dentry

There are man pages:

stap	systemtap program usage, language summary
stappaths	your systemtap installation paths
stapprobes	probes / probe aliases provided by built-in tapsets
stapex	a few basic example scripts
tapset::*	summaries of the probes and functions in each tapset
probe::*	detailed descriptions of each probe
function::*	detailed descriptions of each function

## 各类方式监控kill

[揭开服务程序“被杀”之谜](https://cloud.tencent.com/developer/article/1639080)


## ebpf

[一文带你深入探索 eBPF 可观测性技术底层奥秘](https://cloud.tencent.com/developer/article/2329533)

### eBPF 在生产环境的落地及应用

自从 2014 年 eBPF 技术的问世以来，在过去的几年发展岁月里，eBPF 已经被多家大公司大规模使用，现在我们正在进入一个 eBPF 的使用逐渐成为主流的时代。

1. 2016 年，Netflix 成为广泛采用 eBPF 进行跟踪的先驱，该方案的实施者Brendan Gregg 因其在基础设施和运营领域的专业知识而成为 eBPF 的权威人物。
2. 2017 年， Facebook 开源了基于 eBPF 技术，名为 Katran 的负载均衡器。自那时起，每个发送到 Facebook.com 的数据包都经过 eBPF 处理，从而显示了 eBPF 在 Facebook 的网络架构中的重要性。
3. 2020 年，Google 将 eBPF 纳入其 Kubernetes 产品的一部分。eBPF 现在为Google Kubernetes Engine（GKE）的网络、安全和可观察层提供支持。此外，像Capital One 和 Adobe 等公司也广泛采用了 eBPF 技术作为核心基建技术。
4. 2021 年，Facebook、Google、Netflix、Microsoft 和 Isovalent 共同宣布成立 eBPF 基金会，旨在管理和推动 eBPF 技术的发展。这个基金会的成立凸显了这些科技巨头对 eBPF 的重视，并将进一步促进 eBPF 在各个领域的应用和创新。

如今，eBPF 已经成为数千家公司使用的技术，并且每年都涌现出数百个新的 eBPF 项目，用于探索各种不同的用例。

### eBPF 可观测性是如何工作的呢？

`Hook（钩子）`是一种特殊的机制，用于在特定事件发生时触发 eBPF 程序。

* Hook（钩子）可以存在于内核空间或用户空间
* Hook（钩子）可以是预先确定的或静态的，也**可以动态插入到正在运行的系统**中，而无需重新启动系统。
    * 预先确定的 Hook（钩子）是在编译或配置阶段就确定的，它们在程序或系统启动时就已经存在。
    * 动态插入的 Hook（钩子）是在系统运行时动态添加的，可以根据需要灵活地插入或移除 Hook（钩子），而无需重新启动整个系统。

针对上述机制，eBPF 提供了`四种`不同的操作机制，以满足各种需求和场景。

1. **内核跟踪点(Kernel Tracepoints)**：内核跟踪点是由内核开发人员预定义的事件，可以使用 `TRACE_EVENT` 宏在内核代码中设置。这些跟踪点允许 eBPF 程序挂接到特定的内核事件，并捕获相关数据进行分析和监控。
2. **USDT（User Statically Defined Tracing）**：USDT 是一种机制，允许开发人员在应用程序代码中设置预定义的跟踪点。通过在代码中插入特定的标记，eBPF 程序可以挂接到这些跟踪点，并捕获与应用程序相关的数据，以实现更细粒度的观测和分析。
3. **Kprobes（Kernel Probes）**：Kprobes 是一种内核探针机制，允许 eBPF 程序在运行时动态挂接到内核代码的任何部分。通过在目标内核函数的入口或出口处插入探针，eBPF 程序可以捕获函数调用和返回的参数、返回值等信息，从而实现对内核行为的监控和分析。
4. **Uprobes（User Probes）**：Uprobes 是一种用户探针机制，允许 eBPF 程序在运行时动态挂接到用户空间应用程序的任何部分。通过在目标用户空间函数的入口或出口处插入探针，eBPF 程序可以捕获函数调用和返回的参数、返回值等信息，以实现对应用程序的可观察性和调试能力。

上述机制让 eBPF 能够与内核和应用程序交互，捕获关键事件和数据，并实现深入的`可观察性`和`调试`功能。

Kprobe 主要提供了三种形式的探测点：

1. 基础 Kprobe：作为最为基本的探测方式，是实现后两种的基础，它可以在任意的位置放置探测点（就连函数内部的某条指令处也可以），它提供了探测点的调用前、调用后和内存访问出错3种回调方式
    * 1) pre_handler 函数将在被探测指令被执行前回调；
    * 2) post_handler 会在被探测指令执行完毕后回调（注意不是被探测函数）；‍
    * 3) fault_handler 会在内存访问出错时被调用；
    * Kprobe 是其他内核调试工具(perf，systemtap)的基础设施，同时内核 BPF 也是依赖于 Kprobe
2. Jprobe：用于探测某一个函数的入口，并且能够访问对应的函数参数，这个目前已经不再使用。
3. Kretprobe：用于完成指定函数返回值的探测功能，内核函数的退出点。

### 什么场景下应该选用 eBPF 可观测性？

1. 如果我们的服务实例正在运行现代的云原生环境，如 Kubernetes 和微服务架构，我们会发现基于 eBPF 的方法和基于代理的方法之间存在明显差异。基于 eBPF 的方法通常具有更低的性能开销，更高的安全性，并且更容易安装和部署。通过与内核紧密集成，eBPF 能够在运行时提供更高效的观测和监控功能，而无需引入额外的代理或中间件。这使得基于 eBPF 的方法成为现代云原生环境中的首选解决方案。
2. 其次，对于大规模运营的组织来说，基于 eBPF 的轻量级代理能够带来显著的改进。这是因为 eBPF 提供了高度灵活且可编程的观测能力，允许通过内核级别的监控来获取深入的洞察力。对于像 LinkedIn、Netflix 和 Meta 这样具有大量足迹的科技公司来说，他们采用 eBPF 的原因之一就是它能够满足他们规模和复杂性的需求，提供更高效、更精确的监控和故障排除。
3. 如果我们的团队技术储备有限，并且正在寻找一种几乎不需要安装和维护的观测解决方案，那么直接选择基于 eBPF 的解决方案是一个不错的选择。eBPF 提供了一种以编程方式配置和管理观测功能的方法，而无需额外的基础设施或复杂的设置。这使得我们可以快速启用和配置 eBPF 程序，获取所需的监控数据，而无需处理繁琐的安装和维护任务。

