# 动态追踪技术笔记

性能优化和问题定位中，动态追踪技术都有很大的施展空间，此处做为学习和实践记录

## SystemTap

官网手册：https://sourceware.org/systemtap/tutorial/

### 基本介绍

基本中文介绍，参考：https://zhuanlan.zhihu.com/p/347313289  
(*具体用法和一手内容还是建议到上述官网去消化，下述`官网文档笔记记录`小节*)

systemtap是一个用于简化linux系统运行形态信息收集的开源工具。它立足于性能诊断和bug调试，消除了开发人员在收集数据时需要经历的繁琐和破坏性的工具、重新编译、安装和重新引导的过程。使开发人员在应用层即可实现hook内核

工作原理是通过**将脚本语句翻译成C语句，编译成内核模块**。模块加载之后，将所有探测的事件以钩子的方式挂到内核上，当任何处理器上的某个事件发生时，相应钩子上句柄就会被执行。最后，当systemtap会话结束之后，钩子从内核上取下，移除模块。整个过程用一个命令 stap 就可以完成。

基本用法：

1. `stap 脚本`，可以传参，并用 $N(表示整数) 或 @N(表示字符串) 引用
2. `stap -e '实现'` 通过命令行指定脚本内容(单引号和双引号均可)
    - 如：`stap -e 'probe syscall.* { }'`
3. `stap -l '单个探测点'`，相对脚本，该方式只有一个探测点
    - 如：`stap -l 'syscall.*'`，部分结果：syscall.wait4
4. `stap -L '单个探测点'`
    - 和-l类似，不过匹配的探测点会加上参数说明
    - 如：`stap -L 'syscall.*'`，部分结果：syscall.wait4 name:string pid:long status_uaddr:long options:long options_str:string rusage_uaddr:long argstr:string

语法简介：

* 脚本命名
    - 脚本名字符合linux文件命名即可。一般名字后辍使用".stp"
* 注释
    - 脚本支持多种注释方式，# 、//、/**/ 均可
    - 类似其他脚本，systemtap脚本在开头也需要标明脚本解析器的路径，一般是"#!/usr/bin/stap"，不确定可用which查询
* 变量
    定义全局变量需要加"global"
    数组必须被定义成"global"变量，默认大小不超过2048(MAXMAPENTRIES)，定义时可以省略大小
    支持关联数组(哈希数组)，关联数组中的索引或键由一个或多个字符串或整数值(逗号隔开)组成：
        arr1[“foo”] = 14
        arr2[“coords”,3,42,7] = “test”
* 控制
    - 和C一样
    - 支持foreach语法
* 函数
    - function testfunc:int (i:int){}，类型在后面
    - probe函数
        + 探测内核函数
            * probe kernel.function("kernel_function_name"){ ... }
        + 模块函数
            * probe module("module_name").function("module_function_name") { ... }
    - 函数名支持通配符
    - 在函数末尾加上“.call”或“.return”，分别表示函数被调用和返回时probe
* 可通过命令行传参给脚本
    - "$N" 引用整数类型
    - "@N" 引用字符串类型。如果字符串中间有空格，需要在字符串两边加上双引号
    - 示例
        + stap script.stp sometext 42，脚本中引用时：printf(“arg1: %s, arg2: %d\n”, "@1", $2)

安装：  
yum install systemtap

另需：  
yum install kernel-devel

另外需要 kernel-debuginfo和kernel-debuginfo-common包，需要下载rpm包 (调试内核必然需要安装内核debuginfo包)  
    注意kernel-debug是另外的包，和上面debuginfo不同  
    根据后续的实验结果，stap翻译脚本文件时需要debuginfo包，注意是kernel-debuginfo，而不是kernel-debug-debuginfo包

### 安装和简单示例操作

先 `yum install systemtap` 安装systemtap，网上文章说要另外安装kernel-devel、kernel-debuginfo和kernel-debuginfo-common。

先不装其他包，看执行会缺少什么东西，开始踩坑之旅。

实例(stap -L)：(https://zhuanlan.zhihu.com/p/347345502)

1) 新增test.c写简单逻辑，-g编译成可执行文件
2) stap查看该程序探测点

    stap -L 'process("a.out").function("*")'

    报错：Checking "/lib/modules/4.4.77/build/.config" failed with error: No such file or directory

```
    原因(网上找的，下面实验确认)：最开始只安装了systemtap，需要内核开发包kernel-devel
        安装时提示3.10.0-1160内核(小版本也要特别注意)，还是报错。填的http的yum源是3.10内核的，卸载刚安装的kernel-devel
        制作本地yum源，7.7 everything，默认就是3.10，还是先维持3.10内核
    调整grub加载顺序，让加载的内核为3.10
        /boot/grub2/grub.cfg中， set default="1"(看环境第1个是4.4.77，第2个是3.10)
    安装了还是一样，暂卸载kernel-devel
    /lib/modules/3.10.0-1062.el7.x86_64/build是软连接，指向不存在
        Incorrect version or missing kernel-devel package, use: yum install kernel-devel-3.10.0-1062.el7.x86_64 
        [root@localhost xd]# ll /lib/modules/3.10.0-1062.el7.x86_64/build
        lrwxrwxrwx. 1 root root 39 Dec  1  2020 /lib/modules/3.10.0-1062.el7.x86_64/build -> /usr/src/kernels/3.10.0-1062.el7.x86_64
    /usr/src/kernels/3.10.0-1160.el7.x86_64.debug存在，手动调整软连接指向该目录，在该`-L`示例里可以了。
    ( **但其他功能还是受影响，在下例中需要编译ko的场景下，小版本也必须一致！具体见下面示例**)
        ln -sf /usr/src/kernels/3.10.0-1160.el7.x86_64.debug /lib/modules/3.10.0-1062.el7.x86_64/build
```

基本功能操作: stap -e

```
[root@localhost xd]# stap -ve 'probe begin{printf("Hello, World\n"); exit();}'
Pass 1: parsed user script and 481 library scripts using 275188virt/72448res/3484shr/69212data kb, in 760usr/40sys/803real ms.
Pass 2: analyzed script: 1 probe, 1 function, 0 embeds, 0 globals using 276904virt/74292res/3704shr/70928data kb, in 10usr/0sys/9real ms.
Pass 3: translated to C into "/tmp/stap4Y7BwP/stap_746b6d746dec95b9c5547db709e646df_985_src.c" using 276904virt/74816res/4208shr/70928data kb, in 0usr/0sys/0real ms.
Pass 4: compiled C into "stap_746b6d746dec95b9c5547db709e646df_985.ko" in 9580usr/2120sys/12312real ms.
Pass 5: starting run.
ERROR: Couldn't insert module '/tmp/stap4Y7BwP/stap_746b6d746dec95b9c5547db709e646df_985.ko': Invalid module format
WARNING: /usr/bin/staprun exited with status: 1
Pass 5: run completed in 10usr/0sys/15real ms.
Pass 5: run failed.  [man error::pass5]
```

排查尝试：

```
    安装kernel-devel，报错一样
    安装kernel-debuginfo、kernel-debuginfo-common，还是一样的报错
        搜索centos-debuginfo，此处选一个阿里云的：https://developer.aliyun.com/mirror/centos-debuginfo/
        uname查看内核版本为3.10.0-1062.el7.x86_64，下载对应版本
            kernel-debuginfo-common-x86_64-3.10.0-1062.el7.x86_64.rpm (61.4MB)
            kernel-debuginfo-3.10.0-1062.el7.x86_64.rpm (437MB，rpm -iv安装时依赖上述的common)
    三个包的内核版本需要一致？上述修改的软连接指定的内核小版本不同，只是强行手动改了软连接
        查看编出来缓存的ko info信息，小版本果然是不同的，上面改的指向不行(系统是3.10.0-1062，但是目录下是1160，这就比较坑了)
        [root@localhost ~]# modinfo /root/.systemtap/cache/7b/stap_7b73a7adf44ee5b3a46d011f337cee93_985.ko
        filename:       /root/.systemtap/cache/7b/stap_7b73a7adf44ee5b3a46d011f337cee93_985.ko
        license:        GPL
        description:    systemtap-generated probe
        license:        GPL
        retpoline:      Y
        rhelversion:    7.9
        srcversion:     623FDCE05AF4D4BCFA508BB
        depends:        
        vermagic:       3.10.0-1160.el7.x86_64.debug SMP mod_unload modversions 
        parm:           _stp_bufsize:buffer size (int)
    安装debuginfo包后，存在1062版本的debug目录，是否可以修改上述的build指向？：
        [root@localhost systemtap_dep]# find / -name "*3.10.0-1062*"
        /usr/src/debug/kernel-3.10.0-1062.el7
        /usr/src/debug/kernel-3.10.0-1062.el7/linux-3.10.0-1062.el7.x86_64
        /usr/src/kernels/3.10.0-1160.el7.x86_64.debug/3.10.0-1062.el7.x86_6
        结果：不行，依赖里面的.config
    find找到一个3.10.0-1062版本(容器镜像)，要不先链接试下
        /data/docker/volumes/7f9b50d518aa1fc84082a5037298fce36e07767120bb92b4d256e4778c879d10/_data/3.10/linux-3.10.0-1062.el7/.config
        ln -sf xxx /lib/modules/3.10.0-1062.el7.x86_64/build
        不报上面的错误了，报错，容器镜像里没带小版本：
            Pass 5: starting run.
            ERROR: module release mismatch (3.10.0 vs 3.10.0-1062.el7.x86_64)
            ERROR: module version mismatch (#1 SMP Tue Jun 14 16:01:32 CST 2022 vs #1 SMP Wed Aug 7 18:08:02 UTC 2019), release 3.10.0
        结果：不行
    装devel后(从挂载的系统镜像里取的该版本rpm)，存在/usr/src/kernels/3.10.0-1062.el7.x86_64/了，还原之前的链接
        可以了。。
```

* 所以正确的顺序是：

    1. yum install systemtap

    2. 安装 yum install kernel-devel，特别注意内核版本

        rpm -qa|grep kernel-devel检查系统内核和该包内核，小版本也必须一致(踩的坑：配置的yum源里的小版本为3.0.10-1160，比1062高一些)

        如果yum源里的内核版本不一样，从镜像mount之后取rpm包进行安装(kernel-devel-3.10.0-1062.el7.x86_64.rpm)

        会安装在/usr/src/kernels

    3. 安装debuginfo包，否则stap 指定脚本时会编译失败  
        WARNING: cannot find module kernel debuginfo: No DWARF information found [man warning::debuginfo]

回顾小结：  
    有主动也有被动给自己设了点坑：  
    1、不安装推荐的包，在出错的边缘试探  
    2、主要依赖的kernel-devel包，安装的版本和内核版本不完全一致，都是3.10.0，但后面的小版本不同  
    3、实验的环境不标准(安装了两个内核，grub启动项不同)，忽略了yum源的内核版本问题  

### 官网文档笔记记录

#### 追踪

几种用法和内建tapset库，具体见：[Tracing](https://sourceware.org/systemtap/tutorial/tutorialse2.html#x4-30002)

(可以find / -name tapset，而后grep去查看具体内建函数的实现)

* 常见用法
    - `begin`、`end`，systemtap会话开始和结束，比如`probe begin{}`里面指定一些标题列打印
    - `kernel.function("sys_open")`，探测进入到指定内核函数(可查看内核源码后指定函数进行探测)
        + `kernel.function("*@net/socket.c").call`，可进一步指定某源码文件及探测时机
    - `syscall.close.return`，探测系统调用，可进一步指定是调用时(.call)还是返回时(.return)
    - `module("ext3").statement(0xdeadbeef)`
    - `timer.ms(200)`，每200ms执行一次，指定exit()则可单次使用
    - `timer.profile`、`perf.hw.cache_misses`、`procfs("status").read`
    - `process("a.out").statement("*@main.c:200")` 可指定用户进程
    - 还有：
        + `probe signal.send` 监测信号发送

* systemtap支持很多内建事件(tapset)，常见内建函数和变量：
    - execname() 当前进程名
        + 如：pmdalinux
    - pid() 当前进程号、tid()当前线程号
    - uid() 当前用户id
    - cpu() 当前cpu号
    - pp() 当前处理探测点的字符串描述
        + 如：kprobe.function("__x64_sys_openat")
    - ppfunc() 探测点函数名
        + __x64_sys_openat
    - print_backtrace() 打印调用栈(如果可能的话，If possible)
        + 试了下打印出来没对应到%s位置，缓冲区或者格式化可能没设置好
    - print_ubacktrace() 打印用户态调用栈(如果可能的话)
    - thread_indent() 是很有用的一个函数
        + 可以输出当前probe所处的可执行程序名称、线程id、函数执行的相对时间和执行的次数（通过空格的数量）信息，它的返回值就是一个字符串。参数delta是在每次调用时增加或移除的空白数量 (未梳理如何得到相对时间的，参考：https://www.cnblogs.com/10087622blog/articles/9592036.html)
        + 查看其实现为：`return _generic_indent (tid(), sprintf("%s(%d)", execname(), tid()), delta)`
        + 如下例所示，这样可以打印函数入口到出口之间，函数执行的时间(us)

```sh
probe kernel.function("*@net/socket.c").call {
  printf ("%s -> %s\n", thread_indent(1), ppfunc())
}
probe kernel.function("*@net/socket.c").return {
  printf ("%s <- %s\n", thread_indent(-1), ppfunc())
}

# 部分结果示例：
# 0 sshd(20817): -> sock_write_iter
# 2 sshd(20817):  -> sock_sendmsg    # 说明执行花了2us
# 53 sshd(20817):  <- sock_sendmsg   # 说明执行花了53us
# 54 sshd(20817): <- sock_write_iter
# 0 sshd(20817): -> sock_poll
```

* 其他
    - argstr 执行时送的参数列表 ?

```sh
# cat strace-open.stp
probe syscall.open
{
  printf ("%s(%d) open (%s)\n", execname(), pid(), argstr)
}
probe timer.ms(4000) # after 4 seconds
{
  exit ()
}
# 说明：可以安装两个探测点，exit则退出整体追踪，此处效果即探测open系统调用，4s后结束(shell命令多为直接调用opencat())
# 执行效果如下：
# irqbalance(1126) open (AT_FDCWD, "/proc/irq/9/smp_affinity", O_RDONLY)
# pmdalinux(1775) open (AT_FDCWD, "/proc/vmstat", O_RDONLY)
```

#### 分析

https://sourceware.org/systemtap/tutorial/tutorialse3.html#x6-70003

systemtap语句和C类似

* 几个实用示例
    - (cpu() == 0 && gettimeofday_s() > 1140498000)	after Feb. 21, 2006, on CPU 0
        + 以后可利用gettimeofday_s()来指定时间点(date -d @xxx可解析查看)

* 几个操作符说明
    - & 取地址
    - $$ pretty打印结构体
    - $$vars pretty打印多个变量
    - @defined 检查是否有效

```sh
# cat inode-watch.stp (功能是监控指定设备上inode号表示的文件读写)
probe kernel.function ("vfs_write"),
      kernel.function ("vfs_read")
{
  if (@defined($file->f_path->dentry)) {
    dev_nr = $file->f_path->dentry->d_inode->i_sb->s_dev
    inode_nr = $file->f_path->dentry->d_inode->i_ino
  } else {
    dev_nr = $file->f_dentry->d_inode->i_sb->s_dev
    inode_nr = $file->f_dentry->d_inode->i_ino
  }

  if (dev_nr == ($1 << 20 | $2) # major/minor device
      && inode_nr == $3)
    printf ("%s(%d) %s 0x%x/%u\n",
      execname(), pid(), ppfunc(), dev_nr, inode_nr)
}
```

执行：

```
# touch /tmp/xd123
# stat -c "%D %i" /tmp/xd123 (-c指定format，%D为16进制的设备号，%i为inode号)
fd00 69921712

# stap inode-watch.stp 0xfd 0 69921712  (而后echo 123 > /tmp/xd12，cat、more等操作均会监控)
zsh(74006) vfs_write 0xfd00000/69921712
zsh(74006) vfs_write 0xfd00000/69921712

cat(74819) vfs_read 0xfd00000/69921712
cat(74819) vfs_read 0xfd00000/69921712
cat(74819) vfs_read 0xfd00000/69921712
cat(74819) vfs_read 0xfd00000/69921712
```

#### tapsets 脚本复用

https://sourceware.org/systemtap/tutorial/tutorialse4.html#x10-150004

* man手册里面有各类tapset说明：
    - `man tapset::` (不回车)然后tab提示
    - 如 man tapset::dentry

There are man pages:

stap	systemtap program usage, language summary
stappaths	your systemtap installation paths
stapprobes	probes / probe aliases provided by built-in tapsets
stapex	a few basic example scripts
tapset::*	summaries of the probes and functions in each tapset
probe::*	detailed descriptions of each probe
function::*	detailed descriptions of each function

## 各类方式监控kill

[揭开服务程序“被杀”之谜](https://cloud.tencent.com/developer/article/1639080)


## ebpf

### 介绍

[官网](https://ebpf.io/zh-cn/get-started/)

[一文带你深入探索 eBPF 可观测性技术底层奥秘](https://cloud.tencent.com/developer/article/2329533)

#### eBPF 在生产环境的落地及应用

自从 2014 年 eBPF 技术的问世以来，在过去的几年发展岁月里，eBPF 已经被多家大公司大规模使用，现在我们正在进入一个 eBPF 的使用逐渐成为主流的时代。

1. 2016 年，Netflix 成为广泛采用 eBPF 进行跟踪的先驱，该方案的实施者Brendan Gregg 因其在基础设施和运营领域的专业知识而成为 eBPF 的权威人物。
2. 2017 年， Facebook 开源了基于 eBPF 技术，名为 Katran 的负载均衡器。自那时起，每个发送到 Facebook.com 的数据包都经过 eBPF 处理，从而显示了 eBPF 在 Facebook 的网络架构中的重要性。
3. 2020 年，Google 将 eBPF 纳入其 Kubernetes 产品的一部分。eBPF 现在为Google Kubernetes Engine（GKE）的网络、安全和可观察层提供支持。此外，像Capital One 和 Adobe 等公司也广泛采用了 eBPF 技术作为核心基建技术。
4. 2021 年，Facebook、Google、Netflix、Microsoft 和 Isovalent 共同宣布成立 eBPF 基金会，旨在管理和推动 eBPF 技术的发展。这个基金会的成立凸显了这些科技巨头对 eBPF 的重视，并将进一步促进 eBPF 在各个领域的应用和创新。

如今，eBPF 已经成为数千家公司使用的技术，并且每年都涌现出数百个新的 eBPF 项目，用于探索各种不同的用例。

#### eBPF 可观测性是如何工作的呢？

`Hook（钩子）`是一种特殊的机制，用于在特定事件发生时触发 eBPF 程序。

* Hook（钩子）可以存在于内核空间或用户空间
* Hook（钩子）可以是预先确定的或静态的，也**可以动态插入到正在运行的系统**中，而无需重新启动系统。
    * 预先确定的 Hook（钩子）是在编译或配置阶段就确定的，它们在程序或系统启动时就已经存在。
    * 动态插入的 Hook（钩子）是在系统运行时动态添加的，可以根据需要灵活地插入或移除 Hook（钩子），而无需重新启动整个系统。

针对上述机制，eBPF 提供了`四种`不同的操作机制，以满足各种需求和场景。

1. **内核跟踪点(Kernel Tracepoints)**：内核跟踪点是由内核开发人员预定义的事件，可以使用 `TRACE_EVENT` 宏在内核代码中设置。这些跟踪点允许 eBPF 程序挂接到特定的内核事件，并捕获相关数据进行分析和监控。
2. **USDT（User Statically Defined Tracing）**：USDT 是一种机制，允许开发人员在应用程序代码中设置预定义的跟踪点。通过在代码中插入特定的标记，eBPF 程序可以挂接到这些跟踪点，并捕获与应用程序相关的数据，以实现更细粒度的观测和分析。
3. **Kprobes（Kernel Probes）**：Kprobes 是一种内核探针机制，允许 eBPF 程序在运行时动态挂接到内核代码的任何部分。通过在目标内核函数的入口或出口处插入探针，eBPF 程序可以捕获函数调用和返回的参数、返回值等信息，从而实现对内核行为的监控和分析。
4. **Uprobes（User Probes）**：Uprobes 是一种用户探针机制，允许 eBPF 程序在运行时动态挂接到用户空间应用程序的任何部分。通过在目标用户空间函数的入口或出口处插入探针，eBPF 程序可以捕获函数调用和返回的参数、返回值等信息，以实现对应用程序的可观察性和调试能力。

上述机制让 eBPF 能够与内核和应用程序交互，捕获关键事件和数据，并实现深入的`可观察性`和`调试`功能。

Kprobe 主要提供了三种形式的探测点：

1. 基础 Kprobe：作为最为基本的探测方式，是实现后两种的基础，它可以在任意的位置放置探测点（就连函数内部的某条指令处也可以），它提供了探测点的调用前、调用后和内存访问出错3种回调方式
    * 1) pre_handler 函数将在被探测指令被执行前回调；
    * 2) post_handler 会在被探测指令执行完毕后回调（注意不是被探测函数）；‍
    * 3) fault_handler 会在内存访问出错时被调用；
    * Kprobe 是其他内核调试工具(perf，systemtap)的基础设施，同时内核 BPF 也是依赖于 Kprobe
2. Jprobe：用于探测某一个函数的入口，并且能够访问对应的函数参数，这个目前已经不再使用。
3. Kretprobe：用于完成指定函数返回值的探测功能，内核函数的退出点。

#### 什么场景下应该选用 eBPF 可观测性？

1. 如果我们的服务实例正在运行现代的云原生环境，如 Kubernetes 和微服务架构，我们会发现基于 eBPF 的方法和基于代理的方法之间存在明显差异。基于 eBPF 的方法通常具有更低的性能开销，更高的安全性，并且更容易安装和部署。通过与内核紧密集成，eBPF 能够在运行时提供更高效的观测和监控功能，而无需引入额外的代理或中间件。这使得基于 eBPF 的方法成为现代云原生环境中的首选解决方案。
2. 其次，对于大规模运营的组织来说，基于 eBPF 的轻量级代理能够带来显著的改进。这是因为 eBPF 提供了高度灵活且可编程的观测能力，允许通过内核级别的监控来获取深入的洞察力。对于像 LinkedIn、Netflix 和 Meta 这样具有大量足迹的科技公司来说，他们采用 eBPF 的原因之一就是它能够满足他们规模和复杂性的需求，提供更高效、更精确的监控和故障排除。
3. 如果我们的团队技术储备有限，并且正在寻找一种几乎不需要安装和维护的观测解决方案，那么直接选择基于 eBPF 的解决方案是一个不错的选择。eBPF 提供了一种以编程方式配置和管理观测功能的方法，而无需额外的基础设施或复杂的设置。这使得我们可以快速启用和配置 eBPF 程序，获取所需的监控数据，而无需处理繁琐的安装和维护任务。

### 开发流程

[eBPF 入门开发实践教程一：Hello World，基本框架和开发流程](https://cloud.tencent.com/developer/article/2312629)

在开发eBPF程序时，有多种开发框架可供选择，如 `BCC（BPF Compiler Collection）libbpf`、`cilium/ebpf`、`eunomia-bpf` 等。虽然不同工具的特点各异，但它们的基本开发流程大致相同。

`eunomia-bpf` 是一个开源的 eBPF 动态加载运行时和开发工具链，它的目的是简化 eBPF 程序的开发、构建、分发、运行。它基于 libbpf 的 CO-RE 轻量级开发框架，支持通过用户态 WASM 虚拟机控制 eBPF 程序的加载和执行，并将预编译的 eBPF 程序打包为通用的 JSON 或 WASM 模块进行分发。
网站：[eunomia-bpf 用户手册: 让 eBPF 程序的开发和部署尽可能简单](https://eunomia.dev/zh/eunomia-bpf/manual/)

以`BCC`开发框架为例，介绍eBPF程序的基本开发流程：

1. 安装BCC工具：根据您的Linux发行版，按照BCC官方文档的指南安装BCC工具和相关依赖。
2. 编写eBPF程序（C语言）：使用C语言编写一个简单的eBPF程序，例如Hello World程序。该程序可以在内核空间执行并完成特定任务，如统计网络数据包数量。
3. 编写用户态程序（Python或C等）：使用Python、C等语言编写用户态程序，用于加载、运行eBPF程序以及与之交互。在这个程序中，您需要使用BCC提供的API来加载和操作内核态的eBPF程序。
4. 编译eBPF程序：使用BCC工具，将C语言编写的eBPF程序编译成内核可以执行的字节码。BCC会在运行时动态从源码编译eBPF程序。
5. 加载并运行eBPF程序：在用户态程序中，使用BCC提供的API加载编译好的eBPF程序到内核空间，然后运行该程序。
6. 与eBPF程序交互：用户态程序通过BCC提供的API与eBPF程序交互，实现数据收集、分析和展示等功能。例如，您可以使用BCC API读取eBPF程序中的map数据，以获取网络数据包统计信息。
7. 卸载eBPF程序：当不再需要eBPF程序时，用户态程序应使用BCC API将其从内核空间卸载。
8. 调试与优化：使用 bpftool 等工具进行eBPF程序的调试和优化，提高程序性能和稳定性。

请注意，其他框架（如libbpf、cilium/ebpf和eunomia-bpf）的开发流程大致相似但略有不同，因此在选择框架时，请参考相应的官方文档和示例。

[ebpf & bcc 中文教程及手册](https://blog.cyru1s.com/posts/ebpf-bcc.html)

[使用C语言从头开发一个Hello World级别的eBPF程序](https://tonybai.com/2022/07/05/develop-hello-world-ebpf-program-in-c-from-scratch/)

### libbpf-bootstrap 开发

perf-tools基于ftrace和perf

(ftrace/bpf等)支持的tracepoint跟踪项，可查看：`/sys/kernel/debug/tracing/`

支持的事件：  `/sys/kernel/debug/tracing/events/`

比如：`SEC("tp/sched/sched_process_exec")`，就可在目录下找到该tracepoint

```sh
[root@anonymous ➜ /sys/kernel/debug ]$ ll  /sys/kernel/debug/tracing/events/sched
total 0
-rw-r--r--. 1 root root 0 Jun  9  2024 enable
-rw-r--r--. 1 root root 0 Jun  9  2024 filter
drwxr-xr-x. 2 root root 0 Jun  9  2024 sched_kthread_stop
drwxr-xr-x. 2 root root 0 Jun  9  2024 sched_kthread_stop_ret
drwxr-xr-x. 2 root root 0 Jun  9  2024 sched_migrate_task
drwxr-xr-x. 2 root root 0 Jun  9  2024 sched_move_numa
drwxr-xr-x. 2 root root 0 Jun  9  2024 sched_pi_setprio
drwxr-xr-x. 2 root root 0 Jun  9  2024 sched_process_exec
drwxr-xr-x. 2 root root 0 Jun  9  2024 sched_process_exit
...
```

所有的`tracepoint`如下(环境为CentOS Linux release 8.5.2111)，可以看到网络相关的`tcp`/`net`/`skb`/`sock`

```sh
[root@anonymous ➜ /sys/kernel/debug/tracing/events ]$ ls   
alarmtimer    context_tracking  ftrace          iomap        mdio     page_isolation  resctrl  syscalls   writeback
amdgpu        cpuhp             gpu_scheduler   iommu        migrate  page_pool       rpm      task       x86_fpu
amdgpu_dm     devlink           hda             irq          module   pagemap         rseq     tcp        xdp
avc           dma_fence         hda_controller  irq_matrix   mptcp    percpu          rtc      thermal    xen
block         drm               hda_intel       irq_vectors  msr      power           sched    timer      xfs
bpf_test_run  enable            header_event    kmem         napi     printk          scsi     tlb        xhci-hcd
bpf_trace     exceptions        header_page     kvm          neigh    qdisc           signal   ucsi
bridge        fib               huge_memory     kvmmmu       net      random          skb      udp
cfg80211      fib6              hyperv          kyber        netlink  ras             smbus    vmscan
cgroup        filelock          i2c             libata       nmi      raw_syscalls    sock     vsyscall
clk           filemap           initcall        mac80211     nvme     rcu             spi      wbt
compaction    fs_dax            intel_iommu     mce          oom      regmap          swiotlb  workqueue
```

## bcc libbpf-tools 功能移植到libbpf-bootstrap

bcc下面的libbpf-tools有一些工具示例，尝试移植一个工具到libbpf-bootstrap中编译

tcpconnect.bpf.c
tcpconnect.c

bcc-master/libbpf-tools/tcpconnect.bpf.c


```c
// .maps在用户空间和内核空间之间存储和共享数据
// 相当于定义了一个 map<int, struct sock*>
struct {
}

enter_tcp_connect(struct pt_regs *ctx, struct sock *sk)
{
    // bpf提供的接口
    // linux-5.10.10\kernel\bpf\helpers.c
    // return (u64) task->tgid << 32 | task->pid;
    __u64 pid_tgid = bpf_get_current_pid_tgid();
    // 没搞懂，为什么高32是pid，按上面返回内容好像反的 (TODO) 大小端问题？
    __u32 pid = pid_tgid >> 32;

    // -p 指定PID 过滤
    if (filter_pid && pid != filter_pid)

    // bpf提供的接口，获取uid
    uid = bpf_get_current_uid_gid();

    // bpf提供的接口，用于在BPF映射中插入或更新元素
    // BPF映射是一种键值对存储结构，用于在eBPF（extended Berkeley Packet Filter）程序中共享数据
    // 前面挂的钩子是：SEC("kprobe/tcp_v4_connect")
    // sockets是本文件里定义的结构体，定义了一个 map<int, struct sock*>
    bpf_map_update_elem(&sockets, &tid, &sk, 0);
}
```

```c
// 注册给 argp 框架
static const struct argp_option opts[] = 

// 定义参数解析后的内容
static struct env 

// 注册给 argp 框架
static error_t parse_arg(int key, char *arg, struct argp_state *state)
// 注册给ebpf框架，接管日志打印
static int libbpf_print_fn
// 信号处理函数，此处简单赋值exiting，后面会在主线程判断该标志
static void sig_int(int signo)
    // 本地定义的函数，libbpf-bootstrap里不提供，暂注释或者把实现拷过来
    if (dump_hash(map_fd, keys, key_size, counts, value_size, &n, &zero))
main
// 定义一个 open_opts 变量，类型：struct bpf_object_open_opts
    // .skel.h 里可以看到其用处
    // 如：static inline struct minimal_bpf *open(const struct bpf_object_open_opts *opts = nullptr);
    LIBBPF_OPTS(bpf_object_open_opts, open_opts);
    // 初始化注册相关函数，函数由各自实现
    static const struct argp argp = {
        .options = opts,
        // 注册参数解析函数 parse_arg
        .parser = parse_arg,
        // 注册提示
        .doc = argp_program_doc,
        .args_doc = NULL,
    };
    // .skel.h骨架struct结构
    struct tcpconnect_bpf *obj;
// btf helper 提供的函数
    // 用于确保内核核心BTF（BPF Type Format）信息的存在。
    // 确保在eBPF工具链环境中存在所需的内核核心BTF信息。如果缺少核心BTF信息，该命令将尝试从用户给定的内核二进制文件中提取核心BTF信息。
    // 如果仍然找不到，它将尝试使用内核源代码中提供的头文件进行解析。
    // libbpf-tools里定义的；libbpf-bootstrap里面没有这个，make时也不会去编译它，bootstrap里先注释
    err = ensure_core_btf(&open_opts);
// 生成的骨架中的接口
    obj = tcpconnect_bpf__open_opts(&open_opts);
```

一些依赖的C程序，放到.h里 (当前的libbpf-bootstrap里Makefile不会编译额外的C文件)

在Makefile里加APPS

```c
// tracepoint 系统调用，进入write()时?
SEC("tp/syscalls/sys_enter_write")
int handle_tp(void *ctx)

SEC("perf_event")
int profile(void *ctx)

SEC("socket")
int socket_handler(struct __sk_buff *skb)

SEC("iter/task")
int get_tasks(struct bpf_iter__task *ctx)

SEC("tc")
int tc_ingress(struct __sk_buff *ctx)

SEC("uprobe//proc/self/exe:uprobed_sub")
int BPF_KPROBE(uprobe_sub, int a, int b)

SEC("usdt/libc.so.6:libc:setjmp")
int BPF_USDT(usdt_auto_attach, void *arg1, int arg2, void *arg3)
```

## eBPF跟踪TCP连接

非ECS（Alibaba Cloud Linux 3.2104 LTS 64位）里做的实验，这里做下记录作为对比。博客里面还是起ECS重新做一遍

## 3. bcc tools 跟踪

从之前"[eBPF学习实践系列（二） -- bcc tools网络工具集](https://xiaodongq.github.io/2024/06/10/bcc-tools-network/)"学习记录的bcc tools工具集中，选取如下工具：

* `tcpstates`，跟踪TCP状态变化，每次连接改变其状态时，tcpstates都会显示一个新行
* `tcptracer`，追踪**已建立连接**的TCP socket，每个connect/accept/close事件都会记录打印
* `tcpdrop`，追踪被内核丢弃的TCP数据包

### 3.1. 实验1：服务端listen不accept

用上述github中的server和client程序：

* `./server`，在服务端 192.168.1.101 上启动`8080`端口
* `./client 192.168.1.101 10`，在客户端 192.168.1.102 上并发请求10次

1、服务端信息

1）`/usr/share/bcc/tools/tcpstates -L 8080` （bcc tools默认安装在/usr/share/bcc/tools/目录）

服务端跟踪本地8080端口结果如下，只有6个ESTABLISHED，且最后变成 CLOSE_WAIT 就不动了。netstat也能看到8080有6个CLOSE_WAIT。

```sh
[root@localhost tools]# /usr/share/bcc/tools/tcpstates -L 8080
SKADDR           C-PID C-COMM     LADDR           LPORT RADDR           RPORT OLDSTATE    -> NEWSTATE    MS
ffff9c0ee49f9d40 186798 server     0.0.0.0         8080  0.0.0.0         0     CLOSE       -> LISTEN      0.000

ffff9c0552bda700 0     swapper/0  0.0.0.0         8080  0.0.0.0         0     LISTEN      -> SYN_RECV    0.000
ffff9c0552bda700 0     swapper/0  192.168.1.101  8080  192.168.1.102  51968 SYN_RECV    -> ESTABLISHED 0.018
ffff9c0502b21d40 0     swapper/4  0.0.0.0         8080  0.0.0.0         0     LISTEN      -> SYN_RECV    0.000
ffff9c0502b21d40 0     swapper/4  192.168.1.101  8080  192.168.1.102  51958 SYN_RECV    -> ESTABLISHED 0.018
ffff9c0502b209c0 0     swapper/4  0.0.0.0         8080  0.0.0.0         0     LISTEN      -> SYN_RECV    0.000
ffff9c0502b209c0 0     swapper/4  192.168.1.101  8080  192.168.1.102  51976 SYN_RECV    -> ESTABLISHED 0.004
ffff9c0502b22700 0     swapper/4  0.0.0.0         8080  0.0.0.0         0     LISTEN      -> SYN_RECV    0.000
ffff9c0502b22700 0     swapper/4  192.168.1.101  8080  192.168.1.102  51986 SYN_RECV    -> ESTABLISHED 0.003
ffff9c04cbad57c0 0     swapper/8  0.0.0.0         8080  0.0.0.0         0     LISTEN      -> SYN_RECV    0.000
ffff9c04cbad57c0 0     swapper/8  192.168.1.101  8080  192.168.1.102  51964 SYN_RECV    -> ESTABLISHED 0.012
ffff9c0552bda700 0     swapper/0  192.168.1.101  8080  192.168.1.102  51968 ESTABLISHED -> CLOSE_WAIT  0.567
ffff9c05f016eb40 0     swapper/2  0.0.0.0         8080  0.0.0.0         0     LISTEN      -> SYN_RECV    0.000
ffff9c05f016eb40 0     swapper/2  192.168.1.101  8080  192.168.1.102  51988 SYN_RECV    -> ESTABLISHED 0.017
ffff9c05f016eb40 0     swapper/2  192.168.1.101  8080  192.168.1.102  51988 ESTABLISHED -> CLOSE_WAIT  0.566
ffff9c0502b22700 0     swapper/2  192.168.1.101  8080  192.168.1.102  51986 ESTABLISHED -> CLOSE_WAIT  0.610
ffff9c0502b209c0 0     swapper/2  192.168.1.101  8080  192.168.1.102  51976 ESTABLISHED -> CLOSE_WAIT  0.634
ffff9c0502b21d40 0     swapper/4  192.168.1.101  8080  192.168.1.102  51958 ESTABLISHED -> CLOSE_WAIT  0.560
ffff9c04cbad57c0 0     swapper/8  192.168.1.101  8080  192.168.1.102  51964 ESTABLISHED -> CLOSE_WAIT  0.648
```

根据 SKADDR 列过滤看具体某个socket变化，如 ffff9c04cbad57c0

```sh
ffff9c04cbad57c0 0     swapper/8  0.0.0.0         8080  0.0.0.0         0     LISTEN      -> SYN_RECV    0.000
ffff9c04cbad57c0 0     swapper/8  192.168.1.101  8080  192.168.1.102  51964 SYN_RECV    -> ESTABLISHED 0.012
ffff9c04cbad57c0 0     swapper/8  192.168.1.101  8080  192.168.1.102  51964 ESTABLISHED -> CLOSE_WAIT  0.648
```

2）`/usr/share/bcc/tools/tcptracer -p $(pidof server)`，没抓到内容

3）`/usr/share/bcc/tools/tcpdrop -4`，没抓到内容

这个环境（这个实验不是在上面ECS环境做的）上之前tcpdrop报错了，手动改过，不确定是改的问题还是本来就抓不到（TODO 换其他环境）

```sh
The tcp_drop() function has been inlined in RHEL9 x86_64 kernel and isn't traceable anymore.

This has been finally fixed by the rebase to version 0.25.0
https://bugzilla.redhat.com/show_bug.cgi?id=2033151
```

4）溢出统计情况

```sh
# 请求前：
[root@localhost ~]# netstat -s|grep -i listen
    85 times the listen queue of a socket overflowed
    85 SYNs to LISTEN sockets dropped

# 多次检查溢出统计，每次加4次溢出，可知其为4个客户端重发SYN请求
[root@localhost ~]# netstat -s|grep -i listen
    101 times the listen queue of a socket overflowed
    101 SYNs to LISTEN sockets dropped
[root@localhost ~]# netstat -s|grep -i listen
    105 times the listen queue of a socket overflowed
    105 SYNs to LISTEN sockets dropped
[root@localhost ~]# netstat -s|grep -i listen
    109 times the listen queue of a socket overflowed
    109 SYNs to LISTEN sockets dropped
# 后面就不动了
[root@localhost ~]# netstat -s|grep -i listen
    113 times the listen queue of a socket overflowed
    113 SYNs to LISTEN sockets dropped
```

5）打断server程序，变成CLOSE，netstat看没有8080相关内容了，应该收到了RST（后面又试了一次，抓包看确实是RST）

```sh
ffff9c0ee49f9d40 186798 server     0.0.0.0         8080  0.0.0.0         0     LISTEN      -> CLOSE       823073.810
ffff9c0502b21d40 186798 server     192.168.1.101  8080  192.168.1.102  51958 CLOSE_WAIT  -> CLOSE       718131.499
ffff9c0552bda700 186798 server     192.168.1.101  8080  192.168.1.102  51968 CLOSE_WAIT  -> CLOSE       718131.567
ffff9c04cbad57c0 186798 server     192.168.1.101  8080  192.168.1.102  51964 CLOSE_WAIT  -> CLOSE       718131.490
ffff9c0502b209c0 186798 server     192.168.1.101  8080  192.168.1.102  51976 CLOSE_WAIT  -> CLOSE       718131.500
ffff9c0502b22700 186798 server     192.168.1.101  8080  192.168.1.102  51986 CLOSE_WAIT  -> CLOSE       718131.515
ffff9c05f016eb40 186798 server     192.168.1.101  8080  192.168.1.102  51988 CLOSE_WAIT  -> CLOSE       718131.540
```

第二次尝试时，打断server时的服务端抓包，确实是RST，所以直接变成`CLOSE`了

```sh
[root@localhost ~]# tcpdump -r 8080.cap  -nn
reading from file 8080.cap, link-type EN10MB (Ethernet), snapshot length 262144
dropped privs to tcpdump
12:59:09.487852 IP 192.168.1.101.8080 > 192.168.1.102.48568: Flags [R.], seq 1350646848, ack 1039019527, win 509, options [nop,nop,TS val 3045140028 ecr 1867032119], length 0
12:59:09.487875 IP 192.168.1.101.8080 > 192.168.1.102.48578: Flags [R.], seq 3696534758, ack 1757949962, win 509, options [nop,nop,TS val 3045140028 ecr 1867032119], length 0
12:59:09.487892 IP 192.168.1.101.8080 > 192.168.1.102.48580: Flags [R.], seq 3393769974, ack 3672898952, win 509, options [nop,nop,TS val 3045140028 ecr 1867032120], length 0
12:59:09.487903 IP 192.168.1.101.8080 > 192.168.1.102.48604: Flags [R.], seq 3388981072, ack 1110331342, win 509, options [nop,nop,TS val 3045140028 ecr 1867032120], length 0
12:59:09.487916 IP 192.168.1.101.8080 > 192.168.1.102.48590: Flags [R.], seq 3720239075, ack 2542542395, win 509, options [nop,nop,TS val 3045140028 ecr 1867032120], length 0
12:59:09.487926 IP 192.168.1.101.8080 > 192.168.1.102.48592: Flags [R.], seq 3466164509, ack 4191170730, win 509, options [nop,nop,TS val 3045140028 ecr 1867032120], length 0
```

现象基本符合预期

2、客户端

```sh
# 客户端10次请求分了10个线程并发，每线程只发一次，所以打印有时是乱的
[root@localhost qiuxiaodong]# ./client 192.168.1.101 10
Message sent: helloworldMessage sent: helloworld
Message sent: helloworld
Message sent: helloworld
Message sent: helloworld

Message sent: helloworld
# 等了挺久，最后报错
Connection FailedConnection Failed
Connection Failed

Connection Failed
```

客户端报错退出前可观察到SYN_SENT，退出后就没有8080相关连接了：

```sh
[root@localhost ~]# netstat -anp|grep client
tcp        0      1 192.168.1.102:52006    192.168.1.101:8080     SYN_SENT    18684/./client      
tcp        0      1 192.168.1.102:52020    192.168.1.101:8080     SYN_SENT    18684/./client      
tcp        0      1 192.168.1.102:51996    192.168.1.101:8080     SYN_SENT    18684/./client      
tcp        0      1 192.168.1.102:51998    192.168.1.101:8080     SYN_SENT    18684/./client
```

```sh
/usr/share/bcc/tools/tcpstates -D 8080
```



### 3.2. 实验2：nc正常实验，客户端发起关闭

服务端`nc -l 8090`，客户端curl，curl一次服务端会自动关闭。

监测到服务端收到客户端主动发起的FIN关闭

```sh
SKADDR           C-PID C-COMM     LADDR           LPORT RADDR           RPORT OLDSTATE    -> NEWSTATE    MS
ffff9c04cb811500 1214733 nc         ::              8090  ::              0     CLOSE       -> LISTEN      0.000

ffff9c05f0168000 1245401 tail       0.0.0.0         8090  0.0.0.0         0     LISTEN      -> SYN_RECV    0.000
ffff9c05f0168000 1245401 tail       192.168.1.101   8090  192.168.1.102  52948  SYN_RECV    -> ESTABLISHED 0.017
ffff9c05f0168000 0     swapper/2    192.168.1.101   8090  192.168.1.102  52948  ESTABLISHED -> CLOSE_WAIT  0.249
ffff9c05f0168000 0     swapper/2    192.168.1.101   8090  192.168.1.102  52948  LAST_ACK    -> CLOSE       0.044
ffff9c05f0168000 1214733 nc         192.168.1.101   8090  192.168.1.102  52948  CLOSE_WAIT  -> LAST_ACK    0.015
ffff9c04cb811500 1214733 nc         ::              8090  ::              0     LISTEN      -> CLOSE       47670.823
```

此时 tcptracer 也可以抓到信息（正常3次握手成功才能抓到）

```sh
[root@localhost tools]# /usr/share/bcc/tools/tcptracer -p 1214733 -t
Tracing TCP established connections. Ctrl-C to end.
TIME(s)  T  PID    COMM             IP SADDR            DADDR            SPORT  DPORT 

0.000    A  1214733 nc               4  192.168.1.101   192.168.1.102   8090   52948 
0.000    X  1214733 nc               4  192.168.1.101   192.168.1.102   8090   52948
```

### 3.3. 实验3：正常实验，服务端发起关闭

python起服务，客户端curl请求。

监测到服务端主动发起FIN关闭

```sh
[root@localhost tools]# /usr/share/bcc/tools/tcpstates -L 8000
SKADDR           C-PID C-COMM     LADDR           LPORT RADDR           RPORT OLDSTATE    -> NEWSTATE    MS
ffff9c04cbad57c0 0     swapper/8  0.0.0.0         8000  0.0.0.0         0     LISTEN      -> SYN_RECV    0.000
ffff9c04cbad57c0 0     swapper/8  192.168.1.101   8000  192.168.1.102   56292 SYN_RECV    -> ESTABLISHED 0.013
ffff9c04cbad57c0 1421971 python   192.168.1.101   8000  192.168.1.102   56292 ESTABLISHED -> FIN_WAIT1   1.615
ffff9c04cbad57c0 1421971 python   192.168.1.101   8000  192.168.1.102   56292 FIN_WAIT1   -> FIN_WAIT1   0.033
ffff9c04cbad57c0 0     swapper/8  192.168.1.101   8000  192.168.1.102   56292 FIN_WAIT1   -> FIN_WAIT2   0.199
ffff9c04cbad57c0 0     swapper/8  192.168.1.101   8000  192.168.1.102   56292 FIN_WAIT2   -> CLOSE       0.015
```

```sh
[root@localhost tools]# /usr/share/bcc/tools/tcptracer -p 1421971 -t
Tracing TCP established connections. Ctrl-C to end.
TIME(s)  T  PID    COMM             IP SADDR            DADDR            SPORT  DPORT 

0.000    A  1421971 python           4  192.168.1.101   192.168.1.102   8000   56292 
0.002    X  1421971 python           4  192.168.1.101   192.168.1.102   8000   56292
```

## 自己开发丢包跟踪ebpf程序

对于上面vmlinux.h在不同内核的区别，这里有个直观的例子

1、libbpf-bootstrap-master\vmlinux\x86\vmlinux_601.h：

```c
struct trace_event_raw_kfree_skb {
 struct trace_entry ent;
 void *skbaddr;
 void *location;
 short unsigned int protocol;
 enum skb_drop_reason reason;
 char __data[0];
};
```

2、从环境里用bpftool重新生成的vmlinux.h

```c
struct trace_event_raw_kfree_skb {
 struct trace_entry ent;
 void *skbaddr;
 void *location;
 short unsigned int protocol;
 char __data[0];
};
```

3、新内核加了个丢包理由 `enum skb_drop_reason reason;`

而当前环境A里是不支持的。这也解释了用tcpdrop时，在环境A没抓到drop的原因
这也体现了libbpf CO-RE的价值，一次编译到处运行

## bpftrace

[bpftrace github](https://github.com/bpftrace/bpftrace)

一行教程：
[tutorial_one_liners](https://github.com/bpftrace/bpftrace/blob/master/docs/tutorial_one_liners.md)

包含12个常用方式：

* 1、`bpftrace -l 'tracepoint:syscalls:sys_enter_*'`

```sh
[root@xdlinux ➜ events ]$ bpftrace -l 'tracepoint:skb:*'
tracepoint:skb:consume_skb
tracepoint:skb:kfree_skb
tracepoint:skb:skb_copy_datagram_iovec
```

* 2、`bpftrace -e 'BEGIN { printf("hello world\n"); }'`

```sh
[root@xdlinux ➜ events ]$ bpftrace -e 'BEGIN { printf("hello world\n"); }'
Attaching 1 probe...
hello world

```

* 3、`bpftrace -e 'tracepoint:syscalls:sys_enter_openat { printf("%s %s\n", comm, str(args.filename)); }'`

访问跟踪点的上下文变量

`common` 是内建变量，表示当前进程名。还有其他内建变量如： pid、tid.
访问上下文中的成员变量，低版本使用`args->filename`方式访问成员
`str()`把一个指针转换成字符串

```sh
# centos8.5这里，用->访问
[root@xdlinux ➜ events ]$ bpftrace -e 'tracepoint:syscalls:sys_enter_openat { printf("%s %s\n", comm, str(args->filename)); }'
Attaching 1 probe...
irqbalance /proc/interrupts
irqbalance /proc/stat
irqbalance /proc/irq/32/smp_affinity
irqbalance /proc/irq/30/smp_affinity
```

* 4、`bpftrace -e 'tracepoint:raw_syscalls:sys_enter { @[comm] = count(); }'`

按进程名统计系统调用次数
`@[comm] = count()` 表示定义一个map，形式为`map<comm, count()>`，还可以给map命名

`count()`是一个map函数

```sh
[root@xdlinux ➜ events ]$ bpftrace -e 'tracepoint:raw_syscalls:sys_enter { @[comm] = count(); }'
Attaching 1 probe...
^C

@[sedispatch]: 1
@[gmain]: 4
@[in:imjournal]: 12
@[sshd]: 17
@[dockerd]: 35
@[NetworkManager]: 44
@[tuned]: 54
@[bpftrace]: 64
@[containerd]: 230

# 给map命名
[root@xdlinux ➜ events ]$ bpftrace -e 'tracepoint:raw_syscalls:sys_enter { @test[comm] = count(); }'
Attaching 1 probe...
^C

@test[sssd]: 1
@test[sedispatch]: 2
@test[sssd_be]: 5
@test[sssd_nss]: 5
@test[gmain]: 6
```

* 5、`bpftrace -e 'tracepoint:syscalls:sys_exit_read /pid == 18644/ { @bytes = hist(args.ret); }'`

过滤进程，进行直方图统计

```sh
[root@xdlinux ➜ events ]$ bpftrace -e 'tracepoint:syscalls:sys_exit_read /pid == 1481/ { @bytes = hist(args->ret); }'
Attaching 1 probe...
^C

@bytes: 
(..., 0)              70 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
[0]                   27 |@@@@@@@@@@@@@@@@@@@@                                |
[1]                   15 |@@@@@@@@@@@                                         |
[2, 4)                 3 |@@                                                  |
[4, 8)                 0 |                                                    |
[8, 16)                0 |                                                    |
[16, 32)              26 |@@@@@@@@@@@@@@@@@@@                                 |
[32, 64)               9 |@@@@@@                                              |
[64, 128)             12 |@@@@@@@@                                            |
[128, 256)             9 |@@@@@@                                              |
[256, 512)             4 |@@                                                  |
[512, 1K)              2 |@                                                   |
[1K, 2K)               1 |                                                    |
[2K, 4K)               1 |                                                    |
[4K, 8K)               0 |                                                    |
[8K, 16K)              7 |@@@@@                                               |
```

可以看到 ret 是返回值，对应的是读取的长度

```sh
[root@xdlinux ➜ events ]$ cat syscalls/sys_exit_read/format 
name: sys_exit_read
ID: 671
format:
	field:unsigned short common_type;	offset:0;	size:2;	signed:0;
	field:unsigned char common_flags;	offset:2;	size:1;	signed:0;
	field:unsigned char common_preempt_count;	offset:3;	size:1;	signed:0;
	field:int common_pid;	offset:4;	size:4;	signed:1;

	field:int __syscall_nr;	offset:8;	size:4;	signed:1;
	field:long ret;	offset:16;	size:8;	signed:1;

print fmt: "0x%lx", REC->ret
```

* 6、`bpftrace -e 'kretprobe:vfs_read { @bytes = lhist(retval, 0, 2000, 200); }'`

跟踪 kretprobe，系统支持的列表，可以查看 `bpftrace -l 'kretprobe:*'`

```sh
[root@xdlinux ➜ events ]$  bpftrace -e 'kretprobe:vfs_read { @bytes = lhist(retval, 0, 2000, 200); }'
Attaching 1 probe...
^C

@bytes: 
(..., 0)              12 |                                                    |
[0, 200)             906 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
[200, 400)            75 |@@@@                                                |
[400, 600)            18 |@                                                   |
[600, 800)            11 |                                                    |
[800, 1000)          173 |@@@@@@@@@                                           |
[1000, 1200)          23 |@                                                   |
[1200, 1400)           4 |                                                    |
[1400, 1600)           5 |                                                    |
[1600, 1800)           6 |                                                    |
[1800, 2000)          15 |                                                    |
[2000, ...)          276 |@@@@@@@@@@@@@@@                                     |
```

* 7、`bpftrace -e 'kprobe:vfs_read { @start[tid] = nsecs; } kretprobe:vfs_read /@start[tid]/ { @ns[comm] = hist(nsecs - @start[tid]); delete(@start[tid]); }'`

统计不同进程花在`read()`上面的时间，各自按花费时间区间以直方图展示，单位是ns

```sh
[root@xdlinux ➜ ~ ]$ bpftrace -e 'kprobe:vfs_read { @start[tid] = nsecs; } kretprobe:vfs_read /@start[tid]/ { @ns[comm] = hist(nsecs - @start[tid]); delete(@start[tid]); }'
Attaching 2 probes...

^C

@ns[NetworkManager]: 
[4K, 8K)               2 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|

@ns[containerd]: 
[8K, 16K)              2 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|

@ns[dockerd]: 
[8K, 16K)              1 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
[16K, 32K)             1 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|

@ns[sshd]: 
[4K, 8K)               2 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
[8K, 16K)              0 |                                                    |
[16K, 32K)             2 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|

@ns[in:imjournal]: 
[4K, 8K)               7 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
[8K, 16K)              1 |@@@@@@@                                             |

@ns[irqbalance]: 
[256, 512)             3 |@@@@@@@@@@@@@@@@@@@                                 |
[512, 1K)              4 |@@@@@@@@@@@@@@@@@@@@@@@@@@                          |
[1K, 2K)               2 |@@@@@@@@@@@@@                                       |
[2K, 4K)               0 |                                                    |
[4K, 8K)               1 |@@@@@@                                              |
[8K, 16K)              8 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
[16K, 32K)             3 |@@@@@@@@@@@@@@@@@@@                                 |
[32K, 64K)             0 |                                                    |
[64K, 128K)            1 |@@@@@@                                              |

@start[6395]: 91660555397772
```


