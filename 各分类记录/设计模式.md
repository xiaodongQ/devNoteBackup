# 设计模式

## 设计原则与思想：面向对象

* 封装、抽象、继承、多态
* 抽象类 和 接口，以及各自应用场景
	- 抽象类是`is-a`关系，是对成员变量和方法的抽象，是为了解决代码复用问题；
	- 接口是`has-a`关系，仅仅是对方法的抽象。是为了解决耦合问题，隔离接口和具体的实现，提高代码的扩展性
	- [08 | 理论五：接口vs抽象类的区别？如何用普通的类模拟抽象类和接口？](https://time.geekbang.org/column/article/165103)
* 基于接口编程而非实现编程
* 多用组合，少用继承
	- [10 | 理论七：为何说要多用组合少用继承？如何决定该用组合还是继承？](https://time.geekbang.org/column/article/169593)
* `贫血模型` 和 `充血模型`
	- 基于贫血模型的MVC架构
		+ MVC 三层架构中的 `M` 表示 `Model`，`V` 表示 `View`，`C` 表示 `Controller`。
			* 它将整个项目分为三层：展示层、逻辑层、数据层
			* MVC 三层开发架构是一个比较笼统的分层方式，落实到具体的开发层面，很多项目也并不会 100% 遵从 MVC 固定的分层方式，而是会根据具体的项目需求，做适当的调整
				- 比如，现在很多 Web 或者 App 项目都是前后端分离的，后端负责暴露接口给前端调用
				- 这种情况下，我们一般就将后端项目分为 `Repository` 层、`Service` 层、`Controller` 层。其中，`Repository` 层负责数据访问，`Service` 层负责业务逻辑，`Controller` 层负责暴露接口
		+ 什么是`贫血模型`
			* 实际上，你可能一直都在用贫血模型做开发，只是自己不知道而已
			* 链接中的web应用程序的类定义示例：`UserBo` 是一个纯粹的数据结构，只包含数据，不包含任何业务逻辑。业务逻辑集中在 `UserService` 中，通过 `UserService` 来操作 `UserBo`。即`Service` 层的数据和业务逻辑，被分割为 `BO` 和 `Service`两个类中
			* 像 `UserBo` 这样，只包含数据，不包含业务逻辑的类，就叫作`贫血模型（Anemic Domain Model）`
			* 这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的`面向过程`的编程风格。
		+ [11 | 实战一（上）：业务开发常用的基于贫血模型的MVC架构违背OOP吗？](https://time.geekbang.org/column/article/169600)
	- 基于充血模型的DDD开发
		+ 什么是`充血模型`
			* 在贫血模型中，数据和业务逻辑被分割到不同的类中
			* `充血模型（Rich Domain Model）`正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的`面向对象`编程风格
		+ 什么是`领域驱动设计（Domain Driven Design，简称 DDD）`
			* 主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互
			* 它被大众熟知，还是基于另一个概念的兴起，那就是微服务
				- 除了监控、调用链追踪、API 网关等服务治理系统的开发之外，微服务还有另外一个更加重要的工作，那就是针对公司的业务，合理地做微服务拆分。而领域驱动设计恰好就是用来指导划分服务的。所以，微服务加速了领域驱动设计的盛行。
			* 即便你没有听说过领域驱动设计，对这个概念一无所知，只要你是在开发业务系统，也或多或少都在使用它。做好领域驱动设计的关键是，看你对自己所做业务的熟悉程度，而并不是对领域驱动设计这个概念本身的掌握程度
			* 实际上，基于充血模型的 DDD 开发模式实现的代码，也是按照 MVC 三层架构分层的。Controller 层还是负责暴露接口，Repository 层还是负责数据存取，Service 层负责核心业务逻辑。它跟基于贫血模型的传统开发模式的区别主要在 Service 层。
				- 在基于充血模型的 DDD 开发模式中，Service 层包含 Service 类和 Domain 类两部分。Domain 就相当于贫血模型中的 BO。不过，Domain 与 BO 的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而 Service 类变得非常单薄
				- 总结一下的话就是，基于贫血模型的传统的开发模式，重 Service 轻 BO；基于充血模型的 DDD 开发模式，轻 Service 重 Domain。
	- 基于贫血模型的传统的开发模式，比较适合业务比较简单的系统开发。相对应的，基于充血模型的 DDD 开发模式，更适合业务复杂的系统开发。比如，包含各种利息计算模型、还款模型等复杂业务的金融系统。
		+ 还有一个非常重要的区别，那就是两种不同的开发模式会导致不同的开发流程

## 设计原则与思想：设计原则

一些经典的设计原则，其中包括，`SOLID`、`KISS`、`YAGNI`、`DRY`、`LOD` 等。

* SOLID
	- SOLID 原则并非单纯的 1 个原则，而是由5个设计原则组成的(SOLID 中的 S、O、L、I、D 这 5 个英文字母)，它们分别是：
		+ `单一职责原则` (Single Responsibility Principle, SRP)
			* 单一职责原则的英文是 `Single Responsibility Principle`，缩写为 `SRP`。
			* 描述：*一个类或者模块只负责完成一个职责（或者功能）(A class or module should have a single reponsibility)*
			* 不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定，可能都是不一样的
			* 不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。
			* [15 | 理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？](https://time.geekbang.org/column/article/171771)
		+ `开闭原则` (Open Closed Principle, OCP)
			* 开闭原则的英文全称是 `Open Closed Principle`，简写为 `OCP`
			* 描述：*软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。(software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification)*
			* 添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。
			* [16 | 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？](https://time.geekbang.org/column/article/176075)
		+ `里式替换原则` (Liskov Substitution Principle, LSP)
			* 里式替换原则的英文翻译是：`Liskov Substitution Principle`，缩写为 `LSP`
				- 这个原则最早是在 1986 年由 Barbara Liskov 提出
			* 描述：*子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏*
			* 多态和里式替换原则说的是不是一回事呢？从链接中的例子和定义描述来看，里式替换原则跟多态看起来确实有点类似，但实际上它们完全是两回事
				- 多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性
			* 理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。
				- 父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。
				- 这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明
			* [17 | 理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？](https://time.geekbang.org/column/article/177110)
		+ `接口隔离原则` (Interface Segregation Principle, ISP)
			* 描述：*客户端不应该强迫依赖它不需要的接口。(Clients should not be forced to depend upon interfaces that they do not use)*
				- 其中的“客户端”，可以理解为接口的调用者或者使用者
				- 链接中的示例，用户相关的一套接口方法中，包含删除用户的操作，对其改进为将特权操作单独定义一个接口，而实现类可以选择实现两个interface
			* 在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口
			* 参考链接中的示例：
				- 支持Redis和Kafka配置信息的热更新，但因为某些原因，我们并不希望对 MySQL 的配置信息进行热更新
				- `interface Updater{void update();}`，`RedisConfig`和`KafkaConfig`都实现了Updater接口，用于进行热更新，`MysqlConfig`则不实现Updater接口
				- 再在一个`ScheduledUpdater`类中进行操作，类中定义了一个Updater成员(这样就可以用多态的方式调用方法了)，并且该成员由构造函数来通过外部定义时进行赋值，实现热更新则`Updater.update()`即可(调用写在`run()`方法中)
				- 使用：定义两个`ScheduledUpdater`变量，并分别送需要支持热更新的`RedisConfig`，`KafkaConfig`类给构造函数，于是就可以各自调用两个变量中的`run()`更新逻辑了
			* 作为对比：如果我们不遵守接口隔离原则，不设计 Updater 和 Viewer 两个小接口，而是设计一个大而全的 Config 接口，让 RedisConfig、KafkaConfig、MysqlConfig 都实现这个 Config 接口，并且将原来传递给 ScheduledUpdater 的 Updater 和传递给 SimpleHttpServer 的 Viewer，都替换为 Config，那会有什么问题呢？
				- 首先，第一种设计思路更加灵活、易扩展、易复用：职责更加单一，单一就意味了通用、复用性好
				- 其次，第二种设计思路在代码实现上做了一些无用功。因为 Config 接口中包含两类不相关的接口。
					+  除此之外，如果我们要往Config中继续添加一个新的接口，那所有的实现类都要改动。相反，如果我们的接口粒度比较小，那涉及改动的类就比较少
			* [18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？](https://time.geekbang.org/column/article/177442)
		+ `依赖反转原则` (Dependency Inversion Principle, DIP)，有时也翻译为`依赖倒置原则`
			* 在讲“依赖反转原则”之前，我们先讲一讲`“控制反转”` (Inversion Of Control，IOC)
				- 示例中的框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。
				- 这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行；在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架
				- 控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计
			* 接下来，我们再来看`依赖注入` (Dependency Injection，DI)
				- 依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧
				- 用一句话来概括就是：不通过new()的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用
			* 依赖反转原则：*高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）*
				- 所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层
			* [19 | 理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？](https://time.geekbang.org/column/article/177444)
* `KISS` (Keep It Simple and Stupid)
	- KISS 原则的英文描述有好几个版本：
		+ Keep It Simple and Stupid
		+ Keep It Short and Simple
		+ Keep It Simple and Straightforward
	- 它们表达的意思其实差不多，翻译成中文就是：*尽量保持简单*
		+ 不过，并不是代码行数越少就越“简单”(Simple)，参考链接中验证IP是否合法的示例，使用正则表达式代码最少，但是正则表达式本身就比较复杂，所以并不满足KISS原则
		+ 如果一段代码的逻辑复杂、实现难度大、可读性也不太好，也不一定违背KISS原则，如示例中KMP算法本身就具有`逻辑`复杂、`实现难度`大、`可读性`差的特点。同样的代码，在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了
	- 如何写出满足 KISS 原则的代码
		+ 不要使用同事可能不懂的技术来实现代码
			* 比如示例中的正则表达式，还有一些编程语言中过于高级的语法等
		+ 不要重复造轮子，要善于使用已经有的工具类库
			* 经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高
		+ 不要过度优化
			* 不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性
	- 实际上代码是否足够简单是一个挺主观的评判，评判代码是否简单，还有一个很有效的间接方法，那就是 code review。如果在 code review 的时候，同事对你的代码有很多疑问，那就说明你的代码有可能不够“简单”，需要优化啦
	- [20 | 理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？](https://time.geekbang.org/column/article/177448)
* `YAGNI` (You Ain’t Gonna Need It)
	- YAGNI 原则的英文全称是：You Ain’t Gonna Need It。直译就是：*你不会需要它*
	- 当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：*不要做过度设计*。
		+ 当然，这并不是说我们就不需要考虑代码的扩展性，预留好扩展点
		+ 比如不要在项目中提前引入不需要依赖的开发包
	- YAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。
* `DRY` (Don’t Repeat Yourself)
	- 中文直译为：不要重复自己。将它应用在编程中，可以理解为：*不要写重复的代码*
	- 实际上，重复的代码不一定违反 DRY 原则，而且有些看似不重复的代码也有可能违反 DRY 原则
	- 三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复
		+ 实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则。
		+ 实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则。
		+ 除此之外，代码执行重复也算是违反 DRY 原则。
	- 提高代码可复用性的一些方法，有以下 7 点。
		+ 减少代码耦合
		+ 满足单一职责原则
		+ 模块化业务与非业务逻辑分离
		+ 通用代码下沉
		+ 继承、多态、抽象、封装
		+ 应用模板等设计模式
	- 此外，复用意识也非常重要。在设计每个模块、类、函数的时候，要像设计一个外部 API 一样去思考它的复用性。
		+ 我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。
	- 我们可以不写可复用的代码，但一定不能写重复的代码。
	- [21 | 理论七：重复的代码就一定违背DRY吗？如何提高代码的复用性？](https://time.geekbang.org/column/article/179607)
* `LOD`(Law of Demeter)
	- 高内聚、松耦合
		+ 所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护
			* 单一职责原则是实现代码高内聚非常有效的设计原则
		+ 所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。 即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。
			* 前面讲的依赖注入、接口隔离、基于接口而非实现编程，以及今天讲的迪米特法则，都是为了实现代码的松耦合。
	- 迪米特法则的英文翻译是：Law of Demeter，缩写是LOD。单从这个名字上来看，我们完全猜不出这个原则讲的是什么。不过，它还有另外一个更加达意的名字，叫作*最小知识原则*，英文翻译为：The Least Knowledge Principle
		+ 每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。
		+ *不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）*
	- [22 | 理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？](https://time.geekbang.org/column/article/179615)

## 设计模式与范式：创建型

* 创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码
	- 创建型模式包括`单例模式`、`工厂模式`、`建造者模式`、`原型模式`
	- `单例模式`用来创建全局唯一的对象
	- `工厂模式`用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类）
	- `建造者模式`是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象
	- `原型模式`针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的
* `单例模式`（Singleton Design Pattern）
	- [41 | 单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？](https://time.geekbang.org/column/article/194035)
	- 经典的设计模式有 `23` 种。其中，常用的并不是很多
	- 一个类只允许创建一个对象（或者实例）
	- 为什么要使用单例？
		+ 处理资源访问冲突
			* 把对象级别的锁，换成类级别的锁，让所有的对象都共享同一把锁
			* 分布式锁也是一种解决资源竞争的办法
			* 并发队列（比如Java中的BlockingQueue）也可以解决这个问题：多个线程同时往并发队列里写日志，一个单独的线程负责将并发队列中的数据，写入到日志文件
			* 相对于上面这些解决方案，单例模式的解决思路就简单一些了：所有的线程共享使用这一个对象
		+ 表示全局唯一类
			* 比如，配置信息类
			* 再比如，唯一递增 ID 号码生成器，如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以，我们应该将 ID 生成器类设计为单例
	- 要实现一个单例，我们需要关注的点有下面几个：
		+ 构造函数需要是 `private` 访问权限的，这样才能避免外部通过 new 创建实例；
		+ 考虑对象创建时的线程安全问题
		+ 考虑是否支持延迟加载
		+ 考虑 `getInstance()` 性能是否高（是否加锁）
	- 实现方式
		+ `饿汉式`
			* 在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的
			* 不过，这样的实现方式不支持延迟加载（在真正用到单例类的时候，再创建实例）
			* 优缺点：
				- 一个观点：如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为
				- 文章支持观点：如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能
				- 采用饿汉式实现方式，将耗时的初始化操作，`提前`到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题。
			* 建议：如果初始化耗时长，则建议还是用饿汉式来提前初始化资源
		+ `懒汉式`
			* 懒汉式相对于饿汉式的优势是支持延迟加载
			* 懒汉式的缺点也很明显，给`getInstance()` 这个方法加了一把大锁（synchronzed）(避免重复`new`)，导致这个函数的并发度很低
				- 该函数在单例使用期间，一直会被调用，如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了
		+ `双重检测`（Java、C++）
			* 饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发
			* 再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。
			* 在这种实现方式中，只要 `instance` 被创建之后，即便再调用 `getInstance()` 函数也不会再进入到加锁逻辑中了
		+ `静态内部类`（Java、C++）
			* 再来看一种比双重检测更加简单的实现方法，那就是利用`静态内部类`
			* 这种实现方法既保证了线程安全，又能做到延迟加载
		+ `枚举`（Java）
	- 单例存在的问题
		+ [42 | 单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？](https://time.geekbang.org/column/article/194068)
		+ 问题
			- 单例对 OOP 特性的支持不友好
				* 违背了基于接口而非实现的设计原则：如果未来某一天，我们希望针对不同的业务采用不同的 ID 生成算法，需要修改所有用到 IdGenerator 类的地方
			- 单例会隐藏类之间的依赖关系
				* 单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽
			- 单例对代码的扩展性不友好
				* 如果未来某一天，我们需要在代码中创建两个实例或多个实例，那就要对代码有比较大的改动
				* 如数据库连接池，希望将慢SQL与其他SQL隔离开来执行。为了实现这样的目的，在系统中创建两个数据库连接池，若设计为单例，就无法适应这样的需求变更
				* 所以，数据库连接池、线程池这类的资源池，最好还是不要设计成单例类。实际上，一些开源的数据库连接池、线程池也确实没有设计成单例类
			- 单例对代码的可测试性不友好
				* 如果单例类依赖比较重的外部资源，比如DB，我们在写单元测试的时候，希望能通过mock的方式将它替换掉。而单例类这种硬编码式的使用方式，导致无法实现 mock 替换
				* 除此之外，如果单例类持有成员变量（比如 IdGenerator 中的 id 成员变量），那它实际上相当于一种全局变量，要考虑别处对其修改
			- 单例不支持有参数的构造函数
				* 比如我们创建一个连接池的单例对象，我们没法通过参数来指定连接池的大小
				* 解决思路有几种：
					+ 先调用一个`init`函数来设置参数并new一个实例，再使用`getInstance()`
					+ 将参数放到 `getIntance()` 方法中（两次调用设置不同参数有一次会失败，需要考虑报错）
					+ 将参数放到另外一个全局变量中（里面的值既可以像下面的代码那样通过静态常量来定义，也可以从配置文件中加载得到），实际上，这种方式是最值得推荐的
		+ 单例有什么替代解决方案
			- 可以用静态方法来实现(获取id的方法：`public static long getId()`)
				* 不过，静态方法这种实现思路，并不能解决我们之前提到的问题
			- 还可以使用依赖注入的方法：`public demofunction(IdGenerator idGenerator) {xxx}`，将单例生成的对象，作为参数传递给函数
				* 可以解决单例 隐藏 类之间依赖关系 的问题
				* 不过，对于单例存在的其他问题，比如对 OOP 特性、扩展性、可测性不友好等问题，还是无法解决
			- 如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类了。比如，通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，由程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。
	- [43 | 单例模式（下）：如何设计实现一个集群环境下的分布式单例模式？](https://time.geekbang.org/column/article/196790)
		+ 单例类中对象的唯一性的作用范围是“进程唯一”的
		+ 如何实现线程唯一的单例？
			- 通过一个HashMap来存储对象，其中key是线程ID，value是对象。这样就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。
			- 实际上，Java 语言本身提供了 `ThreadLocal` 并发工具类，可以更加轻松地实现线程唯一单例
		+ 如何实现集群环境下的单例？
			- 把这个单例对象序列化并存储到外部共享存储区（比如文件），或者存到Redis、etcd
			- 进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象(相当于是每次用共享数据来构造对象)，然后再使用，使用完成之后还需要再存储回外部共享存储区
			- 为了保证任何时刻在进程间都只有一份对象存在，一个进程在获取到对象之后，需要`对对象加锁`(此处的锁是分布式锁)，避免其他进程再将其获取；在进程使用完这个对象之后，需要显式地`将对象从内存中删除`，并且`释放对对象的加锁`
		+ 如何实现一个多例模式？
			- “多例”指的就是一个类可以创建多个对象，但是个数是有限制的
			- 通过一个 `Map` 来存储对象类型和对象之间的对应关系，来控制对象的个数
* `工厂模式`（Factory Design Pattern）
	- [44 | 工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？](https://time.geekbang.org/column/article/197254)
	- 一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂
		+ 简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用
		+ 抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用
	- 简单工厂（Simple Factory）
		+ 为了让类的职责更加单一、代码更加清晰，将创建不同情况的类剥离到一个独立的类中，让这个类只负责对象的创建。这个类就是`简单工厂模式类`
		+ 大部分工厂类都是以“`Factory`”这个单词结尾的(但不是必须的)，如`RuleConfigParserFactory`
			* 除此之外，工厂类中创建对象的方法一般都是 `create` 开头，比如代码中的`createParser()`
			* 有的也命名为 `getInstance()`、`createInstance()`、`newInstance()`，有的甚至命名为 `valueOf()`
		+ 实际上，如果每次返回的类实例可以复用，为了节省内存和对象创建的时间，我们可以将不同情况的类事先创建好缓存起来(利用static的map变量)，这种实现叫简单工厂模式的第二种实现方法(每次新建类实例则叫简单工厂模式的第一种实现方法)
		+ 总结
			* 尽管简单工厂模式的代码实现中，有多处if分支判断逻辑，违背开闭原则，但权衡扩展性和可读性，这样的代码实现在大多数情况下（比如，不需要频繁地添加 parser，也没有太多的 parser）是没有问题的。
	- 工厂方法（Factory Method）
		+ 如果非得要将 if 分支逻辑去掉，那该怎么办呢？比较经典处理方法就是利用`多态`。实际上，这就是工厂方法模式的典型代码实现
		+ 工厂方法模式比起简单工厂模式更加符合开闭原则
		+ 为了避免使用时需要判断返回不同类型的工厂类，可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象(参见文章代码更清晰)
	- 抽象工厂（Abstract Factory）
		+ 如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应 8 个 parser 类；若未来还需要增加针对业务配置的解析器（比如 IBizConfigParser），那就要再对应地增加 4 个工厂类
		+ 抽象工厂就是针对这种非常特殊的场景而诞生的。可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数
	- 简单工厂方法和工厂方法的选择
		+ 当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离
			* 第一种情况：类似规则配置解析的例子，代码中存在 if-else 分支判断，动态地根据不同的类型创建不同的对象
				- 针对这种情况，我们就考虑使用工厂模式，将这一大坨 if-else 创建对象的代码抽离出来，放到工厂类中
			* 还有一种情况，尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作
				- 在这种情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中
		+ 对于第一种情况
			* 当每个对象的创建逻辑都比较简单的时候，推荐使用`简单工厂模式`，将多个对象的创建逻辑放到一个工厂类中；
			* 当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的简单工厂类，推荐使用`工厂方法模式`，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中
		+ 对于第二种情况
			* 因为单个对象本身的创建逻辑就比较复杂，所以，建议使用`工厂方法`模式
		+ 除了刚刚提到的这几种情况之外，如果创建对象的逻辑并不复杂，那我们就直接通过 `new` 来创建对象就可以了，`不需要`使用工厂模式
	- 工厂模式的作用无外乎下面这四个，这也是判断要不要使用工厂模式的最本质的参考标准
		+ 封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明
		+ 代码复用：创建代码抽离到独立的工厂类之后可以复用
		+ 隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象
		+ 控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁
	- [45 | 工厂模式（下）：如何设计实现一个Dependency Injection框架？](https://time.geekbang.org/column/article/198614)
		+ `依赖注入框架`，或者叫`依赖注入容器`（Dependency Injection Container），简称 `DI 容器`
		+ 实际上，DI 容器底层最基本的设计思路就是基于`工厂模式`的
			* DI容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。
			* 当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”
		+ DI 容器相对于上节课讲的工厂模式的例子来说，它处理的是更大的对象创建工程
			* 上章节中一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而 DI 容器负责的是整个应用中所有类对象的创建
			* 除此之外，DI 容器负责的事情要比单纯的工厂模式要多，比如，它还包括配置的解析、对象生命周期的管理
		+ 一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。
* `建造者模式`（Builder）
	- [46 | 建造者模式：详解构造函数、set方法、建造者模式三种对象创建方式](https://time.geekbang.org/column/article/199674?utm_source=baidu-ad&utm_medium=tycpz-pc&utm_campaign=100023501&utm_content=column1-4-0810&utm_term=pc_interstitial_500)
	- `Builder` 模式，中文翻译为`建造者模式`或者`构建者模式`，也有人叫它`生成器模式`
	- 如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合 `set()` 方法来解决
	- 但是，如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了
		+ 我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。
			* 如果我们把必填属性通过 `set()` 方法设置，那`校验`这些`必填属性是否已经填写`的逻辑就无处安放了。
		+ 如果类的属性之间有一定的*依赖关系*或者*约束条件*，我们继续使用构造函数配合 `set()` 方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了
		+ 如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露 `set()` 方法。构造函数配合 `set()` 方法来设置属性值的方式就不适用了
	- 用法
		+ 把校验逻辑放置到 `Builder` 类中，先创建建造者，并且通过 `set()` 方法设置建造者的变量值，然后在使用 `build()` 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象
		+ 除此之外，我们把要创建类的构造函数改为 `private` 私有权限。这样我们就只能通过建造者来创建该类对象
		+ 并且，要创建的类没有提供任何 `set()` 方法，这样我们创建出来的对象就是不可变对象了
		+ `Builder`类可以设置为内部静态类(`public static class Builder{xxx}`)，也可以设计成独立的非内部类，e.g. `ResourcePoolConfigBuilder`
	- 使用建造者模式创建对象，还能避免对象存在无效状态(一次性初始化好所有的成员变量，避免只有部分成员被初始化)
	- 工厂模式和建造者模式的区别
		+ 工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。
		+ 建造者模式是用来创建一种类型的复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象
* `原型模式`（Prototype Design Pattern）
	- [47 | 原型模式：如何最快速地clone一个HashMap散列表？](https://time.geekbang.org/column/article/200786?utm_source=baidu-ad&utm_medium=tycpz-pc&utm_campaign=100023501&utm_content=column1-4-0810&utm_term=pc_interstitial_500)
	- 原理
		+ 如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的
			* 如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的IO中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。
		+ 这种基于原型来创建对象的方式就叫作`原型设计模式`（Prototype Design Pattern），简称`原型模式`
	- 原型模式的两种实现方法
		+ 原型模式有两种实现方法，深拷贝和浅拷贝
		+ 场景：
			* 系统 A 在启动的时候会从数据库加载保存的日志数据到内存中，并给关键词建立一个散列表索引
			* 另外一个系统B，专门用来分析搜索日志，定期（比如间隔10分钟）批量地更新数据库中的数据，并且标记为新的数据版本
			* 为了保证系统 A 中数据的实时性（不一定非常实时，但数据也不能太旧），系统A需要定期根据数据库中的数据，更新内存中的索引和数据
			* 要求：任何时刻，系统 A 中的所有数据都必须是同一个版本的，要么都是版本 a，要么都是版本 b，不能有的是版本 a，有的是版本 b
			* 除此之外，我们还要求：在更新内存数据的时候，系统 A 不能处于不可用状态，也就是不能停机更新数据
		+ 实现
			* 把正在使用的数据的版本定义为“服务版本”，当我们要更新内存中的数据的时候，我们并不是直接在服务版本（假设是版本 a 数据）上更新，而是重新创建另一个版本数据（假设是版本b数据），等新的版本数据建好之后，再一次性地将服务版本从版本 a 切换到版本 b。这样既保证了数据一直可用，又避免了中间状态的存在
			* 从数据库中读出，然后计算哈希值，构建newKeywords。这个过程显然是比较耗时。为了提高效率，原型模式就派上用场了
				- 拷贝已有对象的数据，更新少量差值
				- 从数据库中取出更新时间>lastUpdateTime的数据，放入到newKeywords中
			* 深拷贝（Deep Copy）和浅拷贝（Shallow Copy）问题
				- 散列表索引中，每个结点存储的 key 是搜索关键词，value 是 SearchWord 对象的内存地址
				- newKeywords 和 currentKeywords 因为指向相同的一组 SearchWord 对象，就会导致currentKeywords 中指向的 SearchWord，有的是老版本的，有的是新版本的，就没法满足我们之前的需求
				- 可以将浅拷贝替换为深拷贝
			* 那如何实现深拷贝呢？下面两种方法
				- 第一种方法：递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止
				- 第二种方法：先将对象序列化，然后再反序列化成新的对象
			* 这两种实现方法，不管采用哪种，深拷贝都要比浅拷贝耗时、耗内存空间。针对我们这个应用场景，有没有更快、更省内存的实现方式呢？
				- 可以先采用浅拷贝的方式创建 newKeywords。对于需要更新的 SearchWord 对象，我们再使用深度拷贝的方式创建一份新的对象，替换 newKeywords 中的老对象(通过对map删除key，再put key)
				- 这也是这个应用场景下，最快速 clone 散列表的方式

## 设计模式与范式：结构型

* 结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题
	- 结构型模式包括：`代理模式`、`桥接模式`、`装饰器模式`、`适配器模式`、`门面模式`、`组合模式`、`享元模式`
* `代理模式`（Proxy Design Pattern）
	- [48 | 代理模式：代理在RPC、缓存、监控等场景中的应用](https://time.geekbang.org/column/article/201823)
	- 代理模式在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能
	- 参照基于接口而非实现编程的设计思想，将原始类对象替换为代理类对象的时候，为了让代码改动尽量少，在链接中的代理模式的代码实现中，代理类和原始类需要实现相同的接口
		+ 但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的（比如它来自一个第三方的类库），我们也没办法直接修改原始类，给它重新定义一个接口
		+ 对于这种外部类的扩展，一般都是采用继承的方式。让代理类继承原始类，然后扩展附加功能。
	- `动态代理`
		+ 上面实现相同接口或者继承方式存在的问题
			* 在代理类中，要将原始类中的所有的方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑
			* 如果要添加的附加功能的类有不止一个，我们需要针对每个类都创建一个代理类
		+ 可以使用动态代理来解决这个问题。所谓`动态代理`（Dynamic Proxy），就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类
			* Java 语言本身就已经提供了动态代理的语法（实际上，动态代理底层依赖的就是 Java 的反射语法）
	- 代理模式的应用场景
		+ 1. 业务系统的非功能性需求开发
			* 代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志
		+ 2. 代理模式在 RPC、缓存中的应用
			* 实际上，RPC 框架也可以看作一种代理模式
				- 通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节
			* 代理模式在缓存中的应用
				- 从配置文件中加载需要支持缓存的接口，以及相应的缓存策略。当请求到来的时候，在 AOP 切面(Java)中拦截请求，如果请求中带有支持缓存的字段，便从缓存（内存缓存或者 Redis 缓存等）中获取数据直接返回
* `桥接模式`（Bridge Design Pattern）
	- [49 | 桥接模式：如何实现支持不同类型和渠道的消息推送系统？](https://time.geekbang.org/column/article/202786)
	- 桥接模式，也叫作桥梁模式，英文是 Bridge Design Pattern
		+ 桥接模式的定义是“*将抽象和实现解耦，让它们可以独立变化*”
			* 另一种更简单的理解方式：*一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。*
				- 非常类似“组合优于继承”设计原则，通过组合关系来替代继承关系，避免继承层次的指数级爆炸
		+ JDBC 驱动是桥接模式的经典应用
			* 当我们把具体的 Driver 实现类（比如，com.mysql.jdbc.Driver）注册到 DriverManager 之后，后续所有对 JDBC 接口的调用，都会委派到对具体的 Driver 实现类来执行
			* 而 Driver 实现类都实现了相同的接口（java.sql.Driver ），这也是可以灵活切换 Driver 的原因
			* JDBC 本身就相当于“抽象”，具体的 Driver（比如，com.mysql.jdbc.Driver）就相当于“实现”
			* JDBC 和 Driver 独立开发，通过对象之间的`组合`关系，组装在一起。JDBC 的所有逻辑操作，最终都委托给 Driver 来执行
	- 桥接模式的应用举例
		+ 设计类`Notification`，根据不同的告警规则，触发不同类型的告警
			* 告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话
			* 通知的紧急程度有多种类型，包括：SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要）
			* 不同的紧急程度对应不同的通知渠道。比如，SERVE（严重）级别的消息会通过“自动语音电话”告知相关人员
		+ 最简单的实现方式
			* 根据紧急程度，if...else分支处理
			* 存在的问题，那就是有很多 if-else 分支逻辑。
				- 实际上，如果每个分支中的代码都不复杂，后期也没有无限膨胀的可能（增加更多 if-else 分支判断），那这样的设计问题并不大，没必要非得一定要摒弃 if-else 分支逻辑
				- 不过，本例显然不符合这个条件。因为每个 if-else 分支中的代码逻辑都比较复杂，发送通知的所有逻辑都扎堆在通知类中
		+ 将不同渠道的发送逻辑剥离出来，形成独立的消息发送类（`MsgSender` 相关类）
			* 其中，`Notification` 类相当于抽象，`MsgSender` 类相当于实现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起
			* `public interface MsgSender { void send(String message); }`
				- 定义发送接口，然后每个具体的渠道都来实现这个接口，如`public class EmailMsgSender implements MsgSender{xxx}`(C++里可用虚基类来实现接口，子类进行继承)
			* `public abstract class Notification {}` 抽象通知类
				- 其中包含`protected MsgSender msgSender;`来实现不同渠道发送消息，然后通过构造或者set方法设置具体渠道，组合的方式
				- 根据具体紧急程度，再继承该抽象类，各自实现抽象函数：`public abstract void notify(String message);`
			* 这样就实现了两个维度的独立扩展
* `装饰器模式`（Decorator Design Pattern）
	- [50 | 装饰器模式：通过剖析Java IO类库源码学习装饰器模式](https://time.geekbang.org/column/article/204845)
	- 装饰器模式相对于简单的组合关系，有两个比较特殊的地方
		+ 装饰器类和原始类*继承同样的父类*，这样我们可以对原始类“嵌套”多个装饰器类
		+ 装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点
			* 符合“组合关系”这种代码结构的设计模式有很多，比如之前讲过的`代理模式`、`桥接模式`，还有现在的`装饰器模式`。尽管它们的代码结构很相似，但是每种设计模式的意图是不同的
			* 拿比较类似的代理模式和装饰器模式来说，代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能
	- 装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原始类添加增强功能
		+ 这也是判断是否该用装饰器模式的一个重要的依据
	- 除此之外，装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。
		+ 为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口
* `适配器模式`(Adapter Design Pattern)
	- [51 | 适配器模式：代理、适配器、桥接、装饰，这四个模式有何区别？](	https://time.geekbang.org/column/article/205912)
	- 适配器模式是一个比较常用的结构型模式，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作
	- 适配器模式有两种实现方式：`类适配器`和`对象适配器`
		+ 类适配器使用`继承`关系来实现(实现接口并继承原有类)
		+ 对象适配器使用`组合`关系来实现(实现接口，并在适配器类中定义一个原类对象)
	- 到底该如何选择使用哪一种呢？判断的标准主要有两个，一个是`Adaptee`(原类) 接口的个数，另一个是`Adaptee`和`ITarget`(统一接口) 的契合程度
		+ 如果 Adaptee 接口并不多，那两种实现方式都可以
		+ 如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义*大部分都相同*，推荐使用类适配器(继承)
			* 因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方式，Adaptor 的代码量要少一些
		+ 如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义*大部分都不相同*，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活
	- 适配器模式应用场景
		+ 适配器模式的应用场景是“接口不兼容”，一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷
			* 如果在设计初期，就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了
		+ 在实际的开发中，什么情况下才会出现接口不兼容呢？
			* 1. 封装有缺陷的接口设计
				- 假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式
			* 2. 统一多个类的接口设计
				- 某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。
			* 3. 替换依赖的外部系统
				- 当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动
			* 4. 兼容老版本接口
				- 在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为 deprecated，并将内部实现逻辑委托为新的接口实现
				- 这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改
			* 5. 适配不同格式的数据
				- 用在不同格式的数据之间的适配，比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用
	- 代理、桥接、装饰器、适配器 4 种设计模式的区别
		+ 代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的代码结构非常相似。
			* 笼统来说，它们都可以称为 `Wrapper` 模式，也就是通过 Wrapper 类*二次封装*原始类
		+ 尽管代码结构相似，但这 4 种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别
			* `代理模式`在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同
			* `桥接模式`的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变
			* `装饰者模式`在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用
			* `适配器模式`是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口








---

## C++设计模式

* [C++ 单例模式](https://zhuanlan.zhihu.com/p/37469260)

```cpp
// 在C++11标准下，《Effective C++》提出了一种更优雅的单例模式实现，使用函数内的 local static 对象。这样，只有当第一次访问getInstance()方法时才创建实例。这种方法也被称为Meyers' Singleton。
// C++0x之后该实现是线程安全的，C++0x之前仍需加锁。
class Singleton
{
private:
	Singleton() { };
	~Singleton() { };
	Singleton(const Singleton&);
	Singleton& operator=(const Singleton&);
public:
	static Singleton& getInstance()
        {
		static Singleton instance;
		return instance;
	}
};
```


