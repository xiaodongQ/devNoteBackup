# 密码学相关学习笔记

## MAC

消息鉴别码（Message Authentication Code，简称MAC）是一种在密码学中用于验证消息完整性和真实性的安全机制。

MAC通常是由一个秘密密钥和消息内容通过某种算法计算得出的一个固定长度的值。接收方使用相同的密钥和算法对收到的消息重新计算MAC，并与接收到的MAC进行比较，以此来确认消息是否被**篡改**，以及发送方的身份是否可信。

工作原理：

1. 密钥共享：发送方和接收方事先共享一个秘密密钥，这个密钥是双方私有的，不被第三方所知。
2. MAC生成：发送方使用共享密钥和消息内容作为输入，通过一个MAC算法（如HMAC）计算出MAC值。这个MAC值通常会附加在消息后面一起发送。
3. MAC验证：接收方接收到消息后，使用相同的共享密钥和消息内容重新计算MAC值，然后将计算得到的MAC值与接收到的MAC值进行对比。

MAC并不提供消息的机密性，即它不会隐藏消息的内容。为了同时保护消息的完整性和机密性，通常需要结合使用MAC和加密算法，例如先对消息进行加密，再对加密后的消息计算MAC，或者使用AEAD（Authenticated Encryption with Associated Data）算法，它同时提供了加密和认证的功能。

## TLS

`TLS（Transport Layer Security，传输层安全协议）`和`HTTPS（Hypertext Transfer Protocol Secure，安全超文本传输协议）`是互联网上用于保护数据传输安全的两个重要协议。

TLS是在`SSL（Secure Sockets Layer，安全套接字层）`的基础上发展起来的，用于在两个通信应用程序之间提供隐私和数据完整性。

TLS协议通常分为两个阶段：握手阶段和记录协议阶段。
    握手阶段负责建立安全连接，包括密钥交换、身份验证和加密算法的协商。记录协议阶段则负责实际的数据加密和传输。

SSL/TLS通信流程(或者直接写作TLS)：

TLS协议由`TLS记录协议(TLS record protocol)`和`TLS握手协议(TLS handshake protocol)`这两层协议叠加而成。

* 位于底层的`TLS记录协议`负责进行**加密**
    * TLS记录协议位于TLS握手协议的下层，是负责使用*对称密码*对消息进行加密通信的部分
    * TLS记录协议中使用了*对称密码*和*消息认证码*，但是具体的算法和共享密钥则是通过后面将要介绍的握手协议在服务器和客户端之间`协商`决定的。
* 位于上层的`TLS握手协议`负责**加密以外**的其他各种操作

上层的握手协议又可以分为4个子协议：

* 握手协议 (Handshake Protocol)
    * 负责在客户端和服务器之间协商决定密码算法和共享密钥
    * 基于证书的认证操作也在这个协议中完成。它是4个子协议中最复杂的一个。
* 密码规格变更协议 (Change Cipher Spec Protocol)
* 警告协议 
    * 用于当发生错误时通知通信对象。当握手协议的过程中产生异常，或者发生消息认证码错误、压缩数据无法解压缩等问题时，会使用该协议。
* 应用数据协议 (Application Data Protocol)
    * 当TLS承载HTTP时，HTTP的请求和响应就会通过TLS的应用数据协议和TLS记录协议来进行传送

a. TLS记录协议，负责消息的压缩、加密以及数据的认证

* 首先，消息被分割成多个较短的片段（fragment），然后分别对每个片段进行压缩。压缩算法需要与通信对象协商决定。(null则默认？)
* 接下来，经过压缩的片段会被加上`消息认证码`，这是为了保证完整性，并进行数据的认证。通过附加消息认证码的MAC值，可以识别出篡改。
    * 与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编号。
    * `单向散列函数`的算法(就是指密码套件？)，以及消息认证码所使用的`共享密钥`(抓包里的key_share？服务器的公钥)都需要与通信对象协商决定。
* 再接下来，经过压缩的片段再加上消息认证码会一起通过`对称密码`(即共享密钥)进行加密。
    * 加密使用`CBC`模式，CBC模式的初始化向量（IV）通过主密码（mastersecret）生成，而对称密码的算法以及共享密钥需要与通信对象协商决定。
* 最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头（header）就是最终的报文数据
    * 。其中，数据类型为TLS记录协议所承载的4个子协议（握手协议、密码规格变更协议、警告协议、应用数据协议）的其中之一。

b. 握手协议，是TLS握手协议的一部分，负责生成共享密钥以及交换证书。
其中，生成共享密钥是为了进行密码通信，交换证书是为了通信双方相互进行认证。

c. 密码规格变更协议，用于密码切换的同步

抓包信息：注意是TLS1.2还是TLS1.3，流程有差别

TLS1.2(1.3没抓到)：
服务端应答 Certificate
    用于证明服务器的身份。它包含服务器的公钥和身份信息，并由一个可信任的证书颁发机构（CA）签名。
Server Key Exchange
    在TLS 1.2及更早版本中，Server Key Exchange主要用于以下两种情况：
        当使用基于Diffie-Hellman（DH）的密钥交换算法时，例如DHE-RSA或ECDHE-ECDSA。在这种情况下，服务器需要向客户端发送`临时的公钥`，以便双方可以计算出会话密钥。
        当使用匿名DH算法（如DH_anon）时，服务器也需要发送Server Key Exchange消息，但此时不包含任何身份验证信息
Server Hello Done


在TLS 1.3中，Server Key Exchange被移除，原因如下：
    TLS 1.3简化了握手过程，以提高性能和安全性。它不再支持旧的、可能不安全的密钥交换算法，如RSA和DHE，而是主要依赖于ECDHE（椭圆曲线Diffie-Hellman）算法。
    在TLS 1.3中，服务器的公钥直接包含在证书中，因此不需要单独的Server Key Exchange消息。
     TLS 1.3引入了0-RTT（零往返时间）握手，允许客户端在握手完成之前就开始发送应用层数据。为了实现这一功能，Server Key Exchange被移除，以减少握手过程中的延迟。

在TLS 1.3中，由于握手过程被简化，Server Hello Done被合并到了Server Hello消息中，不再作为一个单独的消息发送。

### HTTPS

HTTPS是HTTP协议的安全版本，它在HTTP的基础上加入了TLS/SSL层，用于加密所有的HTTP请求和响应。

HTTPS的实现通常涉及以下几个步骤：

* 客户端向服务器发起HTTPS请求。
* 服务器返回包含其公钥的数字证书。
* 客户端验证证书的有效性，并使用公钥加密一个随机生成的对称密钥，然后发送给服务器。
* 服务器使用其私钥解密对称密钥。
* 之后的所有通信都使用这个对称密钥进行加密和解密。

## 对称加密和非对称加密

对称加密算法的特点是加密和解密使用同一个密钥。这意味着如果密钥被泄露，那么数据的安全性将受到威胁。对称加密算法通常比非对称加密算法更快，适用于大量数据的加密。

常见的对称加密算法包括：

* AES（Advanced Encryption Standard，高级加密标准）目前最广泛使用的对称加密算法之一，支持128、192和256位的密钥长度，提供高安全性和效率。
* DES（Data Encryption Standard，数据加密标准）：早期的对称加密标准，使用56位的密钥。由于密钥长度较短，现在已被认为不够安全。
* 3DES（Triple DES，三重数据加密算法）：为了解决DES密钥长度过短的问题，3DES通过三次DES加密来提高安全性，使用112或168位的密钥。
* Blowfish：一种可变密钥长度的对称加密算法，由Bruce Schneier设计，支持32到448位的密钥长度。它的设计目标是速度和安全性。
* Twofish：Blowfish的后续算法，同样由Bruce Schneier参与设计，支持128、192或256位的密钥长度，提供更高的安全性。
* RC4：一种流加密算法，曾经广泛应用于WEP和TLS协议中，但现在由于发现了一些安全问题，其使用已经减少
* ChaCha20：一种现代的流加密算法，由Daniel J. Bernstein设计，用于替代RC4，提供更好的安全性和性能。



非对称加密算法使用一对密钥，一个公钥和一个私钥。公钥可以公开，而私钥必须保密。
    数据可以用公钥加密，但只能用对应的私钥解密；反之亦然。
    非对称加密算法通常比对称加密算法慢，但提供了更好的密钥管理和安全性。

常见的非对称加密算法包括：

* RSA：由Ron Rivest、Adi Shamir和Leonard Adleman发明，是最著名的非对称加密算法之一。
    * 它基于大整数因数分解的困难性，提供数据加密和数字签名功能。
* Diffie-Hellman：一种密钥交换协议，允许双方在不安全的信道上安全地协商共享密钥。它基于离散对数问题的难度。
* ECC（Elliptic Curve Cryptography，椭圆曲线密码学）：基于椭圆曲线上的离散对数问题，提供与RSA相当的安全性，但使用更短的密钥长度，因此在移动设备和资源受限的环境中特别有用。
* DSA（Digital Signature Algorithm，数字签名算法）：专门用于数字签名的非对称加密算法，基于离散对数问题。
* ElGamal：一种基于离散对数问题的加密算法，既可以用于加密数据，也可以用于数字签名。
* ECDSA（Elliptic Curve Digital Signature Algorithm，椭圆曲线数字签名算法）：基于ECC的数字签名算法，提供高效和安全的数字签名功能。

在实际应用中，对称加密和非对称加密通常会结合使用，以充分利用各自的优点，例如在TLS协议中非对称加密用于密钥交换，而对称加密用于加密大量数据。

## KMS

KMS，全称为 Key Management Service（密钥管理服务），是一种用于保护、管理和自动化密钥生命周期的服务。

在现代的IT和云环境中，KMS扮演着至关重要的角色，尤其在处理敏感数据和遵守合规性要求时。它提供了一种安全的方式来存储、生成、使用和销毁密钥，以确保数据的安全性和隐私。

主要功能：密钥存储、生成、使用、撤销和销毁、审计、轮换、访问控制

有许多平台和供应商提供了KMS服务，包括：

* AWS Key Management Service (AWS KMS)：亚马逊云服务的一部分，用于管理和保护密钥。
* Google Cloud KMS：谷歌云平台提供的密钥管理服务。
* Azure Key Vault：微软Azure云平台的密钥管理解决方案。
* HashiCorp Vault：一个开源的工具，用于保护、控制和审计敏感数据的访问。

KMS是现代数据保护和安全架构中的关键组件，尤其在云计算和大数据时代，其作用更加凸显。通过使用KMS，组织可以更好地控制和保护其加密密钥，从而增强整个系统的安全性和合规性。

## 公钥基础设施（PKI）

`公钥基础设施（Public Key Infrastructure，简称PKI）`是一种利用公钥加密技术来实现安全通信的体系结构。

PKI提供了一套管理和使用公钥和私钥对的规则和方法，包括创建、分发、存储、撤销和销毁数字证书，以及管理密钥对的整个生命周期。

PKI的核心组件包括`证书颁发机构（CA）`、`注册机构（RA）`、`证书库`和`证书撤销列表（CRL）`等。

* 证书颁发机构（CA）：负责签发和管理数字证书的可信第三方机构。CA使用其私钥对证书进行数字签名，以证明证书中包含的公钥确实属于证书所声明的实体。 （CA的全称是`Certificate Authority`，中文通常翻译为证书颁发机构或证书权威机构。）
* 注册机构（RA）：有时作为CA的一个子系统，负责验证申请证书的实体的身份信息，并将这些信息提交给CA进行证书签发。
* 证书库：存储和分发数字证书的地方，可以是数据库或目录服务，如LDAP。
* 证书撤销列表（CRL）：由CA维护的一个列表，记录了所有已被撤销的数字证书，用于帮助验证者检查证书的有效性。

### 各种文件格式

* `.cer` 文件格式

.cer 文件格式通常用于存储`X.509标准`的数字证书。这种格式的文件*只包含公钥证书*，不包含私钥。
.cer 文件通常用于在Web浏览器中查看和导出服务器证书，或者在需要验证某一方身份而不需要进行加密或签名操作的情况下使用。

* `.crt` 文件格式

.crt 文件也是用来存储`X.509`数字证书的，与.cer文件类似。
实际上，.crt和.cer文件在内容上是相同的，只是扩展名不同。这种格式的文件常用于服务器配置中，作为服务器证书的存储格式。

* `.pem` 文件格式

.pem 是“Privacy Enhanced Mail”的缩写，但它现在被广泛用于存储各种类型的加密数据，包括数字证书、公钥和私钥。
.pem 文件使用Base64编码，将二进制数据转换为文本格式，便于在网络上传输。
.pem 文件通常以`“-----BEGIN CERTIFICATE-----”`开始，以`“-----END CERTIFICATE-----”`结束，
  对于私钥，则是以`“-----BEGIN PRIVATE KEY-----”`开始，以`“-----END PRIVATE KEY-----”`结束。

* `.key` 文件格式

.key 文件通常用于存储私钥。这种格式的文件可能包含裸私钥数据，也可能经过加密处理，以增加安全性。
.key 文件在很多场景下使用，比如在生成SSL/TLS证书时，服务器管理员会创建一个.key文件来保存私钥，以便在需要时使用。

* `csr`文件

CSR，全称为Certificate Signing Request，即证书签名请求文件。是在申请数字证书过程中生成的一个重要文件。
它包含了申请者的信息以及`公钥`，用于向证书颁发机构（Certificate Authority，CA）请求签发数字证书。CSR文件是PKI（Public Key Infrastructure，公钥基础设施）中一个关键的组成部分，用于确保最终颁发的数字证书与申请者的真实身份相对应。

CSR文件通常包含以下信息：
    * `公钥`：这是从服务器上生成的密钥对中的一部分，用于加密和解密数据。
    * `主题(Subject)`，即申请者的详细信息：包括申请者的名字、组织单位、所在城市、所在州、国家代码以及电子邮件地址。
    * 域名：申请者希望保护的网站的域名。
    * 挑战令牌：这是一种安全机制，用于证明申请者对所请求的域名拥有控制权。
生成CSR文件并申请数字证书的步骤
    * 生成密钥对：首先，使用如RSA、ECDSA等加密算法生成一个公钥和私钥对
    * 创建CSR：然后，使用如OpenSSL等工具，结合申请者的详细信息和`公钥`，创建CSR文件(比如：openssl req -new -newkey rsa:2048 -nodes -keyout mydomain.key -out mydomain.csr，这里的mydomain.key是`生成的私钥文件`(不是上面的私钥)，而mydomain.csr是`生成的CSR文件`)
    * 提交CSR文件：一旦CSR文件生成完成，申请者可以将其提交给所选择的CA。CA会验证申请者提供的信息，如果验证通过，CA将使用申请者提供的公钥信息签发数字证书。
    * 数字证书生成后，通常会被下载并安装在服务器上，与CSR文件中提到的私钥配对使用，以实现HTTPS或其他安全通信协议的加密功能。

* 其他

`id_rsa`是一个常见的私钥文件名，通常与SSH（Secure Shell）协议和RSA加密算法相关联。
在使用SSH进行远程登录或执行其他安全通信任务时，`id_rsa`文件被用来存储用户的RSA私钥，而与之配对的公钥文件则通常命名为`id_rsa.pub`

由于id_rsa包含了敏感的私钥信息，因此必须妥善保管，防止未经授权的访问。


ssh免密登录：

~~方式1：windows本地生成公钥私钥，把自己的公钥内容加到服务器的authorized_keys (`/root/.ssh/authorized_keys`)~~
方式2：直接拷贝服务器里的公钥私钥到windows上，服务器里的authorized_keys里已经提交加好过了公钥内容

过程：
客户端(secureCRT)通过指定密钥方式(也用的是从服务器拷贝的)登录，请求私钥加密，服务端公钥解密认证通过
同理，不用linux设备上登录也是通过同一套私钥，且公钥在安装时都提前加到authorized_keys里了

## 数字证书

在计算机系统和网络中，身份认证通常涉及到用户名、密码、生物特征、智能卡、一次性口令（OTP）等多种方式，但随着技术的发展，`数字证书`和`公钥基础设施（PKI）`成为了实现远程身份认证的一种重要手段。

`数字证书`是一种用于证明网络通信实体（如用户、设备或网站）身份的电子文档。它由一个可信的第三方，即证书颁发机构（CA，Certificate Authority）签发，包含了实体的公钥和身份信息。数字证书基于公钥基础设施（PKI）工作，是实现身份认证、数据加密和完整性检查的关键组件。

证书标准
符合 PKI ITU-T X509 标准，传统标准（.DER .PEM .CER .CRT）
符合 PKCS#7 加密消息语法标准(.P7B .P7C .SPC .P7R)
符合 PKCS#10 证书请求标准(.p10)
符合 PKCS#12 个人信息交换标准（.pfx *.p12）
X509是数字证书的基本规范，而 P7 和 P12 则是两个实现规范，P7 用于数字信封，P12 则是带有私钥的证书实现规范。 

一个标准的X.509数字证书包含以下一些内容：
  证书的版本信息；
  证书的序列号，每个证书都有一个唯一的证书序列号；
  证书所使用的签名算法；
  证书的发行机构名称，命名规则一般采用X.500格式；
  证书的有效期，通用的证书一般采用UTC时间格式，它的计时范围为1950-2049；
  证书所有人的名称，命名规则一般采用X.500格式；
  证书所有人的公开 密钥；
  证书发行者对证书的签名。

* CA颁发数字证书流程：
    CA确认请求者身份后(在线验证/电话确认/要求提供法律文件)，颁发数字证书：使用`CA自己的私钥`和`请求者的公钥及身份信息`进行数字签名

* 浏览器检查证书：
    检查是否由可信任的CA签发。**主要依赖于预装的信任根证书和证书链验证。**
    * 当你安装浏览器或应用程序时，它们会预装一系列根证书（Root Certificates）。这些根证书是由知名的、广受信任的CA（如DigiCert、GlobalSign、Let's Encrypt等）发行的，它们的公钥被嵌入到浏览器或应用程序中。这意味着这些CA的签名会被认为是可信的。
    * 当浏览器或应用程序接收到一个数字证书时，它会检查该证书的签名。但是，签名是由中间CA或直接由网站的私钥完成的，而不是由预装的信任根证书直接签名的。因此，需要通过`证书链`来验证签名的可信度。

证书链：

* 终端实体证书（End Entity Certificate）：这是直接与网站或用户关联的证书，包含公钥和身份信息。
* 中间证书（Intermediate Certificate）：中间证书位于终端实体证书和根证书之间，用于连接这两者。中间证书由根证书或另一个中间证书签发。
* 根证书（Root Certificate）：根证书位于证书链的顶端，由自己签发，其公钥被预装在浏览器或应用程序中。

浏览器上的地址栏，点击锁图标可以查看网站的证书
windows下的证书管理：
1)控制面板，搜`证书管理`，打开的是`本地计算机`的证书管理
2)命令行输：certmgr.msc，打开的是`当前用户`的证书管理

## 数字签名

### 签名、数字信封、证书 概念区分

* `数字签名`主要用于验证数据的真实性和完整性。
    * 通常使用公钥加密体系（非对称加密）中的**私钥来生成**，然后可以使用相应的**公钥来验证**。
    * 数字签名的生成和验证过程通常涉及到散列函数和公钥加密算法。
        * 例如，发送者先对原始数据进行散列，然后用私钥对散列值进行加密，生成数字签名。
        * 接收者使用发送者的公钥解密数字签名，然后将*解密后的散列值*与*自己对原始数据计算的散列值*进行比较，以验证数据的完整性和发送者的真实身份。
* `数字信封`用于保护数据的机密性，同时利用对称加密的效率和公钥加密的安全性。
    * 过程
        * 发送者生成一个`对称密钥`，使用此密钥对数据进行加密。
        * 发送者使用`接收者的公钥`（和数字签名不同，数字签名是用私钥生成签名）对这个`对称密钥`进行加密，形成`“数字信封”`。
        * 加密后的数据和数字信封一起发送给接收者。
        * 接收者使用自己的`私钥`解密数字信封，得到`对称密钥`。
        * 接收者使用解密得到的`对称密钥`对数据进行解密。
    * 数字信封解决了公钥加密效率低下的问题，因为对称加密通常比公钥加密快得多，而公钥加密仅用于加密和解密对称密钥，而不是整个消息或文件。
* `数字证书（Digital Certificate）`用于在网络环境中验证实体的身份，是建立信任关系的基础。
    * 数字证书是一种用于在网络中验证实体身份的`电子文档`。它包含`实体的公钥`和`实体的身份信息`，由一个可信任的第三方——证书颁发机构（CA）进行签名。
    * 作用
        * 身份验证：证明公钥属于特定的实体。
        * 信任传递：通过信任链，从根证书到中间证书再到最终的实体证书，建立起信任关系。
    * 当你访问一个网站时，网站的服务器会向你的浏览器出示数字证书，浏览器会检查证书的有效性，包括验证证书是否由可信任的CA签发，以及证书是否过期或被撤销等，从而决定是否建立安全连接。

数字签名：

保证传输内容的完整性，以防传输中间被篡改

私钥签名，公钥验签。用于验证身份。

常见方式：MD5、SHA1、SHA256、HMAC-SHA1、HMAC-SHA256、MD5WithRSA、SHA1WithRSA等

一般签名时都要进行加盐处理

### SHA1、SHA256

SHA1和SHA256都是`安全散列算法（Secure Hash Algorithm）`的一部分，由美国国家安全局（NSA）设计，美国国家标准与技术研究院（NIST）发布，主要用于数据完整性的校验和密码学安全。

`SHA1`产生一个160位（20字节）的散列值，通常表示为40个十六进制数字。
    它在1995年发布，曾经广泛应用于各种安全场景，如数字签名、SSL证书以及数据校验等。
    *然而，随着时间的推移，SHA1的安全性逐渐被削弱*，主要原因是其抗碰撞性能较差，即找到两个不同输入产生相同输出（散列值）的可能性随着计算能力的提升而增加。
    **2017年**，研究人员成功展示了SHA1的碰撞攻击，这导致了SHA1在很多领域的弃用。

`SHA256`是SHA-2家族的一部分，产生一个256位（32字节）的散列值，通常表示为64个十六进制数字。
    相比于SHA1，SHA256提供了更强的安全性，尤其是在抗碰撞性能方面。由于其输出长度更长，找到两个不同输入产生相同输出的难度显著增加，这使得SHA256在当前的密码学应用中更加安全可靠。
    SHA256被广泛应用于区块链技术（如比特币）、密码存储、SSL证书以及各种安全协议中。

使用场景：

* 数据完整性检查：通过比较文件的散列值，可以检测文件是否被篡改。
* 密码存储：将用户密码散列后存储，即使数据库泄露，散列后的密码也难以被直接破解。
* 数字签名：散列值可以被用于创建数字签名，保证信息的完整性和来源的真实性。
* 区块链：在区块链中，交易数据被散列后形成区块的哈希值，链接成链，保证了数据的不可篡改性。

虽然SHA256目前被认为是安全的，但任何散列算法的抗碰撞性能都会随着计算能力的提升而逐渐降低。
因此，密码学界持续关注新的散列算法，如`SHA3`和未来的`量子安全算法`，以应对未来可能出现的安全挑战。


## TLCP

Transport layer cryptography protocol（TLCP），传输层密码协议

[信息安全技术 传输层密码协议（TLCP）](https://std.samr.gov.cn/gb/search/gbDetailed?id=A47A713B764314ABE05397BE0A0ABB25)

## 国密算法

国密算法是指由中国国家密码管理局制定和推广的一系列密码算法标准，主要用于保障中国国内的信息安全需求。这些算法在政府机构、金融机构、电信行业以及其它关键基础设施中广泛应用，以满足中国的密码学安全标准和合规要求。


国密算法包括`对称加密算法`、`非对称加密算法`、`散列算法`和`随机数生成算法`等。

国密算法的主要标准：

* `SM1`：这是一个分组密码算法，用于对称加密，类似于AES，但具体细节保密，主要用于智能卡等硬件设备。
* `SM2`：基于椭圆曲线密码学（ECC）的非对称加密算法，用于数据加密和数字签名。SM2算法具有较高的安全性，同时比传统的RSA算法更节省资源。
* `SM3`：一个散列函数，类似于SHA-256，用于生成消息摘要，常用于数据完整性检查和数字签名。
* `SM4`：一个公开的分组密码算法，用于对称加密，与AES类似，但设计上有所不同，主要用于加密通信和数据存储。
* `ZUC`（祖冲之算法）：一个流密码算法，用于加密连续的数据流，如在3GPP LTE系统中的空中接口加密。

`SM`是`商用密码`的拼音缩写，代表`Shang Mi`，即`商用`或`商业密码`。

## GB39786

GB 39786-2021 是中国国家标准化管理委员会发布的一项国家标准，全称为《信息安全技术 公钥基础设施 PKI/PMI应用标识符》。这项标准主要规定了公钥基础设施（Public Key Infrastructure, PKI）和证书管理基础设施（Public Key Management Infrastructure, PMI）中应用标识符的编码、使用和管理规则。

GB 39786-2021 标准的目的是为了统一和规范PKI/PMI在各行业和领域的应用标识符，以便于跨系统的互操作性和数据交换。标准中定义了一系列的应用标识符，用于标识不同的PKI/PMI服务和应用，如证书签发、证书撤销列表、时间戳服务等。

主要作用：

* 互操作性：确保不同PKI系统之间可以识别和理解彼此的应用标识符，从而促进证书和相关服务的跨平台使用。
* 标准化：提供一套统一的编码和使用规则，减少因标识符不一致导致的兼容性问题。
* 安全性：通过明确的标识符使用规则，增强PKI/PMI系统的安全性和可靠性，避免因标识符混乱导致的安全漏洞。

[GB39786标准在线预览](http://c.gb688.cn/bzgk/gb/showGb?type=online&hcno=53282C88712CE157043B7A2C590278FC)

## 图解密码技术

第3版